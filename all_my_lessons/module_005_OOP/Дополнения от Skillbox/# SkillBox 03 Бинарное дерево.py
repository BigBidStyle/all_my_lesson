# Бинарное дерево
# Самый простой вид структуры данных типа «дерево» — это бинарное дерево.

# Бинарное дерево состоит из узлов (этим оно похоже на связанный список), каждый из которых имеет не более двух
# дочерних узлов (в отличие от связанного списка), называемых левым и правым поддеревом.

# Каждый узел содержит значение (или ключ) и ссылки на его дочерние узлы.

# Пример реализации бинарного дерева:

class Node:
    def __init__(self, key):
        # Конструктор узла
        self.key = key
        self.left = None
        self.right = None

# Пример создания бинарного дерева
root = Node(10) # Создаём корневой узел
root.left = Node(2) # Добавляем левый дочерний узел
root.right = Node(15) # Добавляем правый дочерний узел

# Визуализация бинарного дерева:
# 10
# / \
# 2 15
# В данном примере мы создали простое бинарное дерево с корневым узлом, левым и правым дочерними узлами. Это самая
# простая форма дерева, в которой каждый узел имеет не более двух дочерних узлов.

# Обратите внимание, что левый узел содержит значение, которое меньше своего «родителя», а правый узел содержит
# значение, которое больше своего «родителя».

# Благодаря этой особенности, деревья часто используют для облегчения поиска элементов.
# Посмотрите пример:

# Здесь и далее — изображения Skillbox

# Каждый узел выполняет оговорённое ранее правило (левый меньше, правый больше). Если вы захотите найти, например,
# число 15, то вам будет нужно следовать следующей логике:

# 15 больше или меньше 50?
# Если меньше, то двигайтесь влево.
# 15 больше или меньше 25?
# Если меньше, то опять двигайтесь влево.
# 15 больше или меньше 10?
# Если больше — двигайтесь вправо.
# И вот вы нашли число 15!

# Подобный поиск происходит очень быстро, но поддержание дерева (добавление элементов) имеет свои особенности.
# Например, дерево может расти неравномерно, новые элементы — добавляться в одну сторону, в итоге глубина конечных
# элементов (листьев) будет различаться слева и справа, это может выглядеть так:

# Вы можете заметить, что в таком случае теряется преимущество поиска, ведь проверяется одно число за другим
# практически линейно (за одну проверку отбрасывается максимум одно число).

# Чтобы получить преимущество в поиске, придётся перебалансировать его. Чем ровнее будет дерево, тем проще будет
# выполнять по нему поиск (так как за одно сравнение будет откинуто больше элементов).

# В итоге дерево из примера может быть приведено к такому виду:

# Теперь все листья имеют одинаковую глубину, дерево сбалансировано и вы можете найти любое из чисел за две проверки
# (в предыдущем примере для поиска числа 1 могло понадобиться пять проверок).

# binarytree
# binarytree — это модуль, который позволяет создавать и визуализировать бинарные деревья и работать с их различными
# типами.

# Он позволяет легко создавать случайные бинарные деревья и обеспечивает методы для их обхода, поиска и других
# операций.

# Для установки модуля binarytree вы можете использовать менеджер пакетов pip. Откройте терминал и выполните
# следующую команду:

# pip install binarytree

# После успешной установки вы можете начать использовать модуль binarytree.

# Посмотрите пример кода, демонстрирующий создание и работу с бинарным деревом с использованием binarytree:

from binarytree import Node

# Создание бинарного дерева вручную
root = Node(10)
root.left = Node(5)
root.right = Node(15)
root.left.left = Node(3)
root.left.right = Node(7)

# Вывод структуры дерева
print("Структура бинарного дерева:")
print(root)

# Обход дерева в прямом порядке (preorder)
def preorder(node):
    if node is not None:
        print(node.value)
        preorder(node.left)
        preorder(node.right)

print("Обход дерева в прямом порядке (preorder):")
preorder(root)

# Поиск элемента в дереве
def search(node, value):
    if node is None or node.value == value:
        return node
    if value < node.value:
        return search(node.left, value)
    return search(node.right, value)

print("Поиск элемента в дереве:")
result = search(root, 7)
if result is not None:
    print("Элемент найден!")
else:
    print("Элемент не найден!")
# В этом примере класс Node импортируется из модуля binarytree и вручную создаётся бинарное дерево.
#
# Затем выводится структура дерева и выполняется его обход в прямом порядке (preorder) с помощью рекурсивной
# функции preorder.
#
# После этого выполняется поиск элемента в дереве с помощью функции search. В примере иллюстрируется базовое
# использование модуля binarytree.
#
# Важно отметить, что модуль binarytree предоставляет и другие возможности, такие как генерация случайных деревьев,
# визуализация дерева и поддержка различных типов бинарных деревьев. Вы можете ознакомиться с подробной документацией
# модуля binarytree.
#
# Бинарные деревья имеют широкий спектр прикладного применения в различных областях. Вот несколько примеров
# прикладного использования бинарных деревьев:
#
# Базы данных.
# Бинарные деревья могут быть использованы в базах данных для построения индексов. Например, в базе данных, содержащей
# миллионы записей, можно использовать бинарное дерево для хранения и быстрого поиска ключей записей. Ключи записей
# будут храниться в узлах дерева, а поиск будет осуществляться по значению ключа.
# Алгоритмы сжатия данных.
# В алгоритмах сжатия данных, таких как алгоритм Хаффмана, бинарные деревья используются для построения оптимальных
# префиксных кодов. При этом каждый символ или символьная последовательность представляются в виде пути от корня
# дерева до соответствующего листового узла.
# Реализация кеша или кеширования данных.
# Бинарные деревья могут быть использованы для создания кеша данных, в которых часто используемые элементы хранятся
# в памяти для быстрого доступа. При поиске элемента в кеше бинарное дерево позволяет эффективно проверять наличие
# элемента и получать его значение.
# Это только несколько примеров прикладного использования бинарных деревьев. Бинарные деревья широко применяются в
# различных областях, в которых требуется организация данных и эффективный доступ к ним.
#
# Продолжить