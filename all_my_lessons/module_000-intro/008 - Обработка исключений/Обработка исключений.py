# -------------------- #
# region Общие сведения.
"""Информация взята из источника: https://all-python.ru/osnovy/obrabotka-isklyuchenij.html

Обработка исключений в Python 3 является мощным механизмом по управлению программой в особых ситуациях. Он позволяет
избежать ее аварийного завершения вследствие внезапных и непредвиденных ошибок. Такая возможность реализована в языке
программирования Python при помощи специальных синтаксических конструкций, позволяющих отлавливать, а затем
обрабатывать исключения для того, чтобы программа всегда выполняла заданный алгоритм.

Что такое исключения?
Разработка программы на любом языке довольно часто бывает связана с возникновением различного рода ошибок,
препятствующих получению желаемого результата. Как правило, не все они приводят к моментальному завершению программы:
некоторые ошибки можно ликвидировать еще на этапе компиляции, другие же способны оставаться незамеченными достаточно
долгое время, а третьи и вовсе не зависят от программиста и возникают лишь в определенных ситуациях."""
import os

"""На сегодняшний день принято выделять такие типы ошибок:"""
# -------------------- #
# region Синтаксические – возникают из-за синтаксических погрешностей кода;
# Синтаксические ошибки являются следствием несоблюдения общепринятых норм языка, например, пропуска круглой скобки
# в предполагаемом месте или некорректного написания имени функции. Такие погрешности успешно отлавливаются
# компилятором, который сразу же сообщает пользователю о проблеме в написанном коде. Следующий пример показывает,
# что будет, если пропустить символ двойных кавычек при создании строкового литерала:

# print("Hello World!)

# После попытки запуска выдастся текст ошибки:
#   File "main.py", line 1
#     print("Hello World!)
#                        ^
# SyntaxError: EOL while scanning string literal

# Синтаксические ошибки являются следствием несоблюдения общепринятых норм языка, например, пропуска круглой скобки в
# предполагаемом месте или некорректного написания имени функции. Такие погрешности успешно отлавливаются компилятором,
# который сразу же сообщает пользователю о проблеме в написанном коде. Следующий пример показывает, что будет, если
# пропустить символ двойных кавычек при создании строкового литерала:

# endregion Синтаксические – возникают из-за синтаксических погрешностей кода;
# -------------------- #
# region Логические – проявляются вследствие логических неточностей в алгоритме;
# Логические ошибки считаются более сложными в выявлении, поскольку не отлавливаются ни на этапе компиляции, ни во
# время выполнения готовой программы. Обычно они вызваны определенными недостатками в логике написанного алгоритма,
# из-за чего пользователь не получает желаемого результата. Ниже показана работа функции, которая должна вычислять
# среднее значение двух чисел, однако она этого не делает из-за неправильной формулы:

# def avg(a, b):
#     return a + b / 2 <--- Нехватает скобок (a + b) / 2
# print(avg(10, 20))

# endregion Логические – проявляются вследствие логических неточностей в алгоритме;
# -------------------- #
# region Исключения – вызваны некорректными действиями пользователя или системы.
# Исключения представляют собой еще один вид ошибок, который проявляется в зависимости от наличия обстоятельств,
# меняющих ход выполнения программы. Примером этому вполне может быть ввод некорректного значения либо отсутствие
# нужного файла. Как правило, все доступные виды исключений становятся видимыми во время выполнения программы. Далее
# продемонстрирован пример, показывающий невозможность операции деления на ноль:

# print(10 / 0)
# После попытки запуска будет выведено:

# Traceback (most recent call last):
# File "main.py", line 1, in <module>
# print(10 / 0)
# ZeroDivisionError: division by zero

# Как можно заметить из результатов выполнения программы, деление на ноль провоцирует исключительную ситуацию, которая
# приводит к аварийному завершению работы и выводу ошибки на экран. В данном случае отображается файл, а также номер
# строки кода, где было выброшено исключение ZeroDivisionError. Ниже приводится краткое описание проблемы.
# endregion Исключения – вызваны некорректными действиями пользователя или системы.
# -------------------- #
# endregion Общие сведения.
# -------------------- #
# region Перехват исключений.
"""Для того, чтобы исключение не приводило к внезапному завершению программы, его стоит обработать. Для этого есть 
специальный механизм, предотвращающего все непредвиденные ситуации. Это поможет избежать сбоев в работе написанного 
алгоритма за счет расширения его возможностей, позволяющих действовать согласно новым обстоятельствам. Но сначала 
попробуем запустить программу, которая попытается открыть обычный текстовый файл:"""

# print("Program started")
# print("Opening file...")
# f = open("data.txt")
# print("Program finished")

""" После запуска будет выведено..."""
# Program started
# Opening file...
# Traceback (most recent call last):
#   File "main.py", line 3, in <module>
#     f = open("data.txt")
# FileNotFoundError: [Errno 2] No such file or directory: 'data.txt'

"""Так как файла с таким именем на жестком диске не обнаружено, программа сгенерировала исключение FileNotFoundError, 
сообщающее о проблеме с вводом/выводом. Последняя строка кода, в которой обозначается завершение программы, не была 
отображена на экране. Это значит, что не все операции, предусмотренные алгоритмом, были выполнены из-за проявившегося 
исключения.

Рассмотрим пример в Python конструкции try-except. Она позволяет обработать исключительную ситуацию без необходимости 
завершения уже работающей программы:"""

print("Перехват исключения.")
try:    # (Попытаться) Опасный код, способный привести к ошибке.
    print('Opening file...')
    f = open("data.txt")
except:  # (Кроме) Инструкции, которые следует выполнить в случае возникнувшей проблемы.
    print('File not found! <-- Сработало исключение.')
print("# -------------------- #")

"""Как видно из кода выше, блок try содержит опасный код, способный привести к ошибке (отсутствие нужного файла), а 
блок except включает в себя инструкции, которые следует выполнить в случае возникнувшей проблемы. Теперь если требуемый 
файл не был найден, программа не станет завершаться, о чем свидетельствует последний вывод функции print."""
# endregion Перехват исключений.
# -------------------- #
# region Несколько блоков except.
"""Блоков except может быть несколько, в зависимости от того, какой тип исключения нужно обработать. Как правило, 
сначала обрабатываются более частные случаи, а затем общие:"""

# print("Несколько блоков except.")
# try:
#     print("Opening file...")
#     f = open("data.txt")
# except FileNotFoundError:
#     print("File not found!")
# except Exception:
#     print("Something gone wrong!")
# print("# -------------------- #")

# endregion Несколько блоков except.
# -------------------- #
# region Вложенные блоки и else. Finally.
"""Блоки try-except могут быть вложенными для более гибкого управления исключениями. В следующем примере 
демонстрируется попытка открыть текстовый файл и записать в него некую строку. Для каждой цели используется отдельный 
блок try.

Также в данном примере используется конструкция else, которая выполняется в случае, если в коде не произошло исключений.

В данном случае — else сработает при успешной операции write. По умолчанию файл открывается на чтение в текстовом 
режиме. Поэтому при открытии файла будем использовать режим «w». В этом режиме файл открывается на запись. Если файла 
не было — создается новый, если был — перезаписывается."""

print("Вложенные блоки и else")
try:
    print("Opening file...")
    f = open("data.txt", "w")
    try:
        print("Writing to file...")
        f.write("Hello World!")
    except Exception:
        print("Something gone wrong!")
    else:
        print("Success!")
except FileNotFoundError:
    print("File not found!")
print("# -------------------- #")

"""finally
Бывают ситуации, когда некие важные действия необходимо совершить вне зависимости от того, было вызвано исключение или 
нет. Для этого используется блок finally, содержащий набор инструкций, которые нужно выполнить в любом случае. 
Следующий пример улучшает работу предыдущей программы, добавляя в нее возможность закрывать текстовый файл"""

# print("Блок finally.")
# try:
#     print("Opening file...")
#     if = open("data.txt", "w")
#     try:
#         print("Writing to file...")
#         f.write("Hello World!")
#     except Exception:
#         print("Something gone wrong!")
#     else:
#         print("Success!")
#     finally:
#         print("Closing file...")
#         f.close()
# except FileNotFoundError:
#     print("File not found!")
# print("# -------------------- #")

"""Иногда такой подход к работе с текстовыми файлами может показаться слишком сложным, так как код, который его 
реализует, выглядит громоздким. Специально для этого существует конструкция with/as, позволяющая автоматизировать 
некоторые методы, такие как закрытие файла у соответствующего объекта. Таким образом, сокращается длина написанного 
кода:"""

# print("Код с with as")
# try:
#     print("Writing to file...")
#     with open("data.txt", "w") as f:
#         f.write("Hello World!")
# except Exception:
#     print("Something gone wrong!")
# print("# -------------------- #")
# endregion Вложенные блоки и else
# -------------------- #
# region Пользовательские исключения.
"""Как правило, исключения автоматически вызываются в нужных ситуациях, однако в Python присутствует возможность 
запускать их самостоятельно. Для этого применяется ключевое слово raise. Следом за ним необходимо создать новый 
объект типа Exception, который потом можно обработать при помощи привычных конструкций try-except, как в данном 
примере:"""

# print("Пользовательские исключения.")
# try:
#     raise Exception("User Exception created!")
# except Exception as e:
#     print(str(e))
# print("# -------------------- #")

"""Чтобы описать собственный тип исключения, нужно создать новый класс, унаследованный от базового типа Exception. 
Это позволит запускать особые виды исключений в ситуациях, когда поведение пользователя не соответствует алгоритму 
программы. В конструкторе Exception указываем текст исключения. После того, как оно сработало и было перехвачено, 
можно его получить с помощью str.

В следующем коде показан процесс генерации исключения NegativeAge, которое не позволяет пользователю ввести 
отрицательный возраст. Таким образом, экран выдает соответствующую ошибку:"""

# class NegativeAge(Exception):
#     pass
#
# print("Создание класса пользовательского исключения.")
# try:
#     age = int(-15)
#     if age < 0:
#         raise NegativeAge("Exception: Negative age!")
#     print("Success!")
#
# except NegativeAge as error:
#     print(error)
# print("# -------------------- #")

# endregion Пользовательские исключения.
# -------------------- #
# region Запись в лог.
"""Для вывода специальных сообщений, не влияющих на функционирование программы, в Python применяется библиотека логов. 
Чтобы воспользоваться ею, необходимо выполнить импорт в верхней части файла. Существует несколько типов логов, 
отобразить которые поможет команда, определенная во второй строке кода в следующем примере программы:"""

# import logging  # Импортируем библиотеку логов.
#
# logging.basicConfig(level = logging.DEBUG)  # Команда отобразить типы логов.
#
# logging.debug("Debug message!") # Отладочное сообщение.
# logging.info("Info message!")   # Информационное сообщение.
# logging.warning("Warning message!") # Предупреждающее сообщение.
# logging.error("Error message!") # Cообщение об ошибке.
# logging.critical("Critical message!")   # Критическое сообщение.

"""Как видно из результатов выполнения программы, пользователю доступны разные типы сообщений, такие как 
предупреждение, информация или ошибка. Обычно они применяются при разработке программного обеспечения, чтобы не 
выводить лишний текст в консоль.

С помощью logging на Python можно записывать в лог и исключения. Обычно лог пишется в файл, зададим его как log.txt. 
Уровень INFO указывает, что сообщения уровнем ниже (в данном случае debug) не будут отражаться в логе. Python позволяет 
в try-except получить текст ошибки, который и запишем:"""

# import logging
# logging.basicConfig(filename="log.txt", level = logging.INFO)
# try:
#     print(10 / 0)
# except Exception as error:
#     logging.error(str(error))

"""В log .txt будет добавлена строка сообщения о типе сработавшего исключения «ERROR:root:division by zero»."""
# endregion Запись в лог.
# -------------------- #
# region Иерархия исключений.
"""В языке программирования Python присутствует строгая иерархия исключений. Вершиной является BaseException, 
включающий в себя все существующие разновидности исключений:

SystemExit – возникает при выходе из программы с помощью sys.exit;
KeyboardInterrupt – указывает на прерывание программы пользователем;
GeneratorExit – появляется при вызове метода close для объекта generator;
Exception – представляет совокупность обычных несистемных исключений.

Перечень несистемных исключений, которые содержит в себе класс Exception приведены в следующей таблице. 
Все они актуальны для последней на данный момент версии Python 3.

ArithmeticError	    Порождается арифметическими ошибками (операции с плавающей точкой, переполнение числовой 
                    переменной, деление на ноль)
AssertionError	    Возникает при ложном выражении в функции assert
AttributeError	    Появляется в случаях, когда нужный атрибут объекта отсутствует
BufferError	        Указывает на невозможность выполнения буферной операции
EOFError	        Проявляется, когда функция не смогла прочитать конец файла
ImportError	        Сообщает о неудачном импорте модуля либо атрибута
LookupError	        Информирует про недействительный индекс или ключ в массиве
MemoryError	        Возникает в ситуации, когда доступной памяти недостаточно
NameError	        Указывает на ошибку при поиске переменной с нужным именем
NotImplementedError	Предупреждает о том, что абстрактные методы класса должны быть обязательно переопределены в 
                    классах-наследниках
OSError	            Включает в себя системные ошибки (отсутствие доступа к нужному файлу или директории, проблемы с 
                    поиском процессов)
ReferenceError	    Порождается попыткой доступа к атрибуту со слабой ссылкой
RuntimeError	    Сообщает об исключении, которое не классифицируется
StopIteration	    Возникает во время работы функции next при отсутствии элементов
SyntaxError	        Представляет собой совокупность синтаксических ошибок
SystemError	        Порождается внутренними ошибками системы
TypeError	        Указывает на то, что операция не может быть выполнена с объектом
UnicodeError	    Сообщает о неправильной кодировке символов в программе
ValueError	        Возникает при получении некорректного значения для переменной
Warning	            Обозначает предупреждение

Исключения являются самостоятельным типом данных, при помощи которого программа сообщает пользователю о различных 
ошибках. Обработка исключений позволяет менять сценарий выполнения программы с учетом обстоятельств, так или иначе 
блокирующих ее нормальную работу. Для удобного управления исключениями в языке программирования Python предусмотрены 
специальные синтаксические конструкции. Кроме того, в нем есть большая библиотека готовых исключений, а также 
возможность создавать собственные."""

# -------------------- #
#BaseException  <--
#  ├── BaseExceptionGroup  <--
#  ├── GeneratorExit  <--
#  ├── KeyboardInterrupt  <--
#  ├── SystemExit  <--
#  └── Exception  <--
#       ├── ArithmeticError  <--
#       │    ├── FloatingPointError  <--
#       │    ├── OverflowError  <--
#       │    └── ZeroDivisionError  <--
#       ├── AssertionError  <-- Возникает, когда assert оператор терпит неудачу.
#       ├── AttributeError  <--
#       ├── BufferError  <--
#       ├── EOFError  <-- Возникает, когда input() функция достигает состояния конца файла (EOF) без чтения каких-либо данных.
#       ├── ExceptionGroup [BaseExceptionGroup]  <--
#       ├── ImportError  <--
#       │    └── ModuleNotFoundError  <-- Подкласс ImportError которого возникает, import когда модуль не может быть найден. Он также возникает, когда None находится в sys.modules.
#       ├── LookupError  <--
#       │    ├── IndexError  <-- Возникает, когда индекс последовательности выходит за пределы допустимого диапазона
#       │    └── KeyError  <-- Возникает, когда ключ сопоставления (словаря) не найден в наборе существующих ключей.
#       ├── MemoryError  <-- Возникает, когда операции не хватает памяти, но ситуацию еще можно спасти (путем удаления некоторых объектов).
#       ├── NameError  <-- Возникает, когда локальное или глобальное имя не найдено
#       │    └── UnboundLocalError  <--
#       ├── OSError  <--Это исключение возникает, когда системная функция возвращает системную ошибку, включая сбои
#       │    │           ввода-вывода, такие как «файл не найден» или «диск заполнен» (не для недопустимых типов
#       │    │           аргументов или других случайных ошибок).
#       │    ├── BlockingIOError  <--
#       │    ├── ChildProcessError  <--
#       │    ├── ConnectionError  <--
#       │    │    ├── BrokenPipeError  <--
#       │    │    ├── ConnectionAbortedError  <--
#       │    │    ├── ConnectionRefusedError  <--
#       │    │    └── ConnectionResetError  <--
#       │    ├── FileExistsError   <-- Возникает при попытке создать файл или каталог, который уже существует.
#       │    ├── FileNotFoundError <-- Возникает, когда файл или каталог запрошен, но не существует.
#       │    ├── InterruptedError  <--
#       │    ├── IsADirectoryError  <--
#       │    ├── NotADirectoryError  <--
#       │    ├── PermissionError  <--
#       │    ├── ProcessLookupError  <--
#       │    └── TimeoutError  <--
#       ├── ReferenceError  <--
#       ├── RuntimeError    <-- Возникает при обнаружении ошибки, не подпадающей ни под одну из других категорий.
#       │    │                 Соответствующее значение представляет собой строку, указывающую, что именно пошло не так.
#       │    ├── NotImplementedError  <--
#       │    └── RecursionError  <--
#       ├── StopAsyncIteration  <--
#       ├── StopIteration  <--
#       ├── SyntaxError  <--
#       │    └── IndentationError  <--
#       │         └── TabError  <--
#       ├── SystemError  <--
#       ├── TypeError  <--
#       ├── ValueError  <--
#       │    └── UnicodeError  <--
#       │         ├── UnicodeDecodeError  <--
#       │         ├── UnicodeEncodeError  <--
#       │         └── UnicodeTranslateError  <--
#       └── Warning  <--
#            ├── BytesWarning  <--
#            ├── DeprecationWarning  <--
#            ├── EncodingWarning  <--
#            ├── FutureWarning  <--
#            ├── ImportWarning  <--
#            ├── PendingDeprecationWarning  <--
#            ├── ResourceWarning  <--
#            ├── RuntimeWarning  <--
#            ├── SyntaxWarning  <--
#            ├── UnicodeWarning  <--
#            └── UserWarning  <--
# endregion Иерархия исключений.