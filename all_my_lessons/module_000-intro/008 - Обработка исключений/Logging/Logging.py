"""Видео обзор этого модуля есть в папке e:\Видео\Python модуль\Module logging.mp4
https://habr.com/ru/companies/wunderfund/articles/683880/"""
# ----------------------------- #
# region Начало работы с Python-модулем logging.
"""В Python имеется встроенный модуль logging, применяемый для решения задач логирования. Им мы будем пользоваться в этом 
руководстве. Первый шаг к профессиональному логированию вы можете выполнить прямо сейчас, импортировав этот модуль в 
своё рабочее окружение."""

import logging
# logger = logging.getLogger()
"""Встроенный модуль логирования Python даёт нам простой в использовании функционал и предусматривает пять уровней 
логирования. Чем выше уровень — тем серьёзнее неприятность, о которой сообщает соответствующая запись. Самый низкий 
уровень логирования — это debug (10), а самый высокий — это critical (50).

Дадим краткие характеристики уровней логирования:

Debug (10): самый низкий уровень логирования, предназначенный для отладочных сообщений, для вывода диагностической 
информации о приложении.

Info (20): этот уровень предназначен для вывода данных о фрагментах кода, работающих так, как ожидается.

Warning (30): этот уровень логирования предусматривает вывод предупреждений, он применяется для записи сведений о 
событиях, на которые программист обычно обращает внимание. Такие события вполне могут привести к проблемам при работе 
приложения. Если явно не задать уровень логирования — по умолчанию используется именно warning.

Error (40): этот уровень логирования предусматривает вывод сведений об ошибках — о том, что часть приложения работает 
не так как ожидается, о том, что программа не смогла правильно выполниться.

Critical (50): этот уровень используется для вывода сведений об очень серьёзных ошибках, наличие которых угрожает 
нормальному функционированию всего приложения. Если не исправить такую ошибку — это может привести к тому, что
 приложение прекратит работу.

В следующем фрагменте кода показано использование вышеперечисленных уровней логирования при выводе нескольких 
сообщений. Здесь используется синтаксическая конструкция logging.<level>(<message>)."""

# logging.debug("A DEBUG Message")
# logging.info("An INFO")
# logging.warning("A WARNING")
# logging.error("An ERROR")
# logging.critical("A message of CRITICAL severity")

"""Ниже приведён результат выполнения этого кода. Как видите, сообщения, выведенные с уровнями логирования warning, 
error и critical, попадают в консоль. А сообщения с уровнями debug и info — не попадают."""

# Результат будет таким
# WARNING:root:A WARNING
# ERROR:root:An ERROR
# CRITICAL:root:A message of CRITICAL severity

"""Это так из-за того, что в консоль выводятся лишь сообщения с уровнями от warning и выше. Но это можно изменить, 
настроив логгер и указав ему, что в консоль надо выводить сообщения, начиная с некоего, заданного вами, уровня 
логирования.

Подобный подход к логированию, когда данные выводятся в консоль, не особо лучше использования print(). На практике 
может понадобиться записывать легируемые сообщения в файл. Этот файл будет хранить данные и после того, как работа 
программы завершится. Такой файл можно использовать в качестве журнала отладки.

Обратите внимание на то, что в примере, который мы будем тут разбирать, весь код находится в файле main.py. Когда мы 
производим рефакторинг существующего кода или добавляем новые модули — мы сообщаем о том, в какой файл (имя которого 
построено по схеме <module-name>.py) попадает новый код. Это поможет вам воспроизвести у себя то, о чём тут идёт 
речь."""
# endregion Начало работы с Python-модулем logging.
# ----------------------------- #
# region Логирование в файл.
"""Для того чтобы настроить простую систему логирования в файл — можно воспользоваться конструктором basicConfig(). 
Вот как это выглядит:"""

logging.basicConfig(level=logging.INFO, filename="Logging.log",filemode="w",encoding='utf-8',
                    format="%(asctime)s %(levelname)s %(message)s")
# logging.debug("A DEBUG Message")
# logging.info("An INFO")
# logging.warning("A WARNING")
# logging.error("An ERROR")
# logging.critical("A message of CRITICAL severity")

"""Поговорим о логгере root, рассмотрим параметры basicConfig():

level: это — уровень, на котором нужно начинать логирование. Если он установлен в info — это значит, что все сообщения 
с уровнем debug игнорируются.

filename: этот параметр указывает на объект обработчика файла. Тут можно указать имя файла, в который нужно 
осуществлять логирование.

filemode: это — необязательный параметр, указывающий режим, в котором предполагается работать с файлом журнала, 
заданным параметром filename. Установка filemode в значение w (write, запись) приводит к тому, что логи 
перезаписываются при каждом запуске модуля. По умолчанию параметр filemode установлен в значение a (append, 
присоединение), то есть — в файл будут попадать записи из всех сеансов работы программы.

После выполнения модуля main можно будет увидеть, что в текущей рабочей директории был создан файл журнала, 
Logging.log.log.

Так как мы установили уровень логирования в значение info — в файл попадут записи с уровнем info и с более высокими 
уровнями

Записи в лог-файле имеют формат <logging-level>:<name-of-the-logger>:<message>. По умолчанию <name-of-the-logger>, 
имя логгера, установлено в root, так как мы пока не настраивали пользовательские логгеры.

Помимо базовой информации, выводимой в лог, может понадобится снабдить записи отметками времени, указывающими на момент 
вывода той или иной записи. Это упрощает анализ логов. Сделать это можно, воспользовавшись параметром конструктора 
format

Существуют и многие другие атрибуты записи лога, которыми можно воспользоваться для того чтобы настроить внешний вид 
сообщений в лог-файле. Настраивая поведение логгера root — так, как это показано выше, проследите за тем, чтобы 
конструктор logging.basicConfig()вызывался бы лишь один раз. Обычно это делается в начале программы, до использования 
команд логирования. Последующие вызовы конструктора ничего не изменят — если только не установить параметр force в 
значение True.
"""
# endregion Логирование в файл.
# ----------------------------- #
# region Логирование значений переменных и исключений.
"""Модифицируем файл logging.py. Скажем — тут будут две переменных — x и y, и нам нужно вычислить значение выражения 
x/y. Мы знаем о том, что при y=0 мы столкнёмся с ошибкой ZeroDivisionError. Обработать эту ошибку можно в виде 
исключения с использованием блока try/except.

Далее — нужно залогировать исключение вместе с данными трассировки стека. Чтобы это сделать — можно воспользоваться 
logging.error(message, exc_info=True). Запустите следующий код и посмотрите на то, как в файл попадают записи с уровнем 
логирования info, указывающие на то, что код работает так, как ожидается."""

def text_logging(x, y):
    logging.info("---------------------------------------")
    logging.info(f"The values of x and y are {x} and {y}.")
    try:
        z = x / y
        logging.info(f"x/y successful with result: {z}.")
    except ZeroDivisionError as err:
        logging.error("ZeroDivisionError",exc_info=True)

text_logging(3, 4)

"""Существуют и многие другие атрибуты записи лога, которыми можно воспользоваться для того чтобы настроить внешний вид 
сообщений в лог-файле. Настраивая поведение логгера root — так, как это показано выше, проследите за тем, чтобы 
конструктор logging.basicConfig()вызывался бы лишь один раз. Обычно это делается в начале программы, до использования 
команд логирования. Последующие вызовы конструктора ничего не изменят — если только не установить параметр force в 
значение True.

Теперь установите значение y в 0 и снова запустите модуль."""
text_logging(3, 0)

"""Исследуя лог-файл py_log.log, вы увидите, что сведения об исключении были записаны в него вместе со стек-трейсом.

Теперь модифицируем код так, чтобы в нём имелись бы списки значений x и y, для которых нужно вычислить коэффициенты x/y.
 Для логирования исключений ещё можно воспользоваться конструкцией logging.exception(<message>).
"""

x_vals = [2,3,6,4,10]
y_vals = [5,7,12,0,1]

for x_val,y_val in zip(x_vals,y_vals):
    x,y = x_val,y_val
    logging.info("---------------------------------------")
    logging.info(f"The values of x and y are {x} and {y}.")
    try:
        res = x / y
        logging.info(f"x/y successful with result: {res}.")
    except ZeroDivisionError as err:
        logging.exception("ZeroDivisionError")

"""Сразу после запуска этого кода можно будет увидеть, что в лог-файл попала информация и о событиях успешного 
вычисления коэффициента, и об ошибке, когда возникло исключение."""
# endregion Логирование значений переменных и исключений.
# ----------------------------- #
# region Рекомендации по организации логирования в Python.
"""До сих пор мы говорили о том, как логировать значения переменных и исключения, как настраивать пользовательские 
логгеры. Теперь же предлагаю вашему вниманию рекомендации по логированию.

Устанавливайте оптимальный уровень логирования. Логи полезны лишь тогда, когда их можно использовать для отслеживания 
важных ошибок, которые нужно исправлять. Подберите такой уровень логирования, который соответствует специфике 
конкретного приложения. Вывод в лог сообщений о слишком большом количестве событий может быть, с точки зрения отладки, 
не самой удачной стратегией. Дело в том, что при таком подходе возникнут сложности с фильтрацией логов при поиске 
ошибок, которым нужно немедленно уделить внимание.

Конфигурируйте логгеры на уровне модуля. Когда вы работаете над приложением, состоящим из множества модулей — вам стоит 
задуматься о том, чтобы настроить свой логгер для каждого модуля. Установка имени логгера в name помогает 
идентифицировать модуль приложения, в котором имеются проблемы, нуждающиеся в решении.

Включайте в состав сообщений логов отметку времени и обеспечьте единообразное форматирование сообщений. Всегда 
включайте в сообщения логов отметки времени, так как они полезны в деле поиска того момента, когда произошла ошибка. 
Единообразно форматируйте сообщения логов, придерживаясь одного и того же подхода в разных модулях.

Применяйте ротацию лог-файлов ради упрощения отладки. При работе над большим приложением, в состав которого входит 
несколько модулей, вы, вполне вероятно, столкнётесь с тем, что размер ваших лог-файлов окажется очень большим. Очень 
длинные логи сложно просматривать в поисках ошибок. Поэтому стоит подумать о ротации лог-файлов. Сделать это можно, 
воспользовавшись обработчиком RotatingFileHandler, применив конструкцию, которая строится по следующей схеме: 
logging.handlers.RotatingFileHandler(filename, maxBytes, backupCount). Когда размер текущего лог-файла достигнет 
размера maxBytes, следующие записи будут попадать в другие файлы, количество которых зависит от значения параметра 
backupCount. Если установить этот параметр в значение K — у вас будет K файлов журнала.

Сильные и слабые стороны логирования
Теперь, когда мы разобрались с основами логирования в Python, поговорим о сильных и слабых сторонах этого механизма.

Мы уже видели, как логирование позволяет поддерживать файлы журналов для различных модулей, из которых состоит 
приложение. Мы, кроме того, можем конфигурировать подсистему логирования и подстраивать её под свои нужды. Но эта 
система не лишена недостатков. Даже когда уровень логирования устанавливают в значение warning, или в любое значение, 
которое выше warning, размеры лог-файлов способны быстро увеличиваться. Происходит это в том случае, когда в один и тот 
же журнал пишут данные, полученные после нескольких сеансов работы с приложением. В результате использование лог-файлов 
для отладки программ превращается в нетривиальную задачу.

Кроме того, исследование логов ошибок — это сложно, особенно в том случае, если сообщения об ошибках не содержат 
достаточных сведений о контекстах, в которых происходят ошибки. Когда выполняют команду logging.error(message), не 
устанавливая при этом exc_info в True, сложно обнаружить и исследовать первопричину ошибки в том случае, если 
сообщение об ошибке не слишком информативно.

В то время как логирование даёт диагностическую информацию, сообщает о том, что в приложении нужно исправить, 
инструменты для мониторинга приложений, вроде Sentry, могут предоставить более детальную информацию, которая способна 
помочь в диагностике приложения и в исправлении проблем с производительностью.

В следующем разделе мы поговорим о том, как интегрировать в Python-проект поддержку Sentry, что позволит упростить 
процесс отладки кода"""
# endregion Рекомендации по организации логирования в Python.

# ----------------------------- #


