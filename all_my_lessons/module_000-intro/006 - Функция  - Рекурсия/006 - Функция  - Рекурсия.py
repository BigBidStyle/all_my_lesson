# region 8.2 Функция - Рекурсия.
# region Задача Факториал числа.
# def factorial(num):
#     if num == 1:
#         return 1
#     fact_n_minus_1 = factorial(num - 1)
#     return num * factorial(num - 1)

# num_fact = factorial(5)
# print(num_fact)
# endregion Задача Факториал числа.
# region Задача Код сайта.
# site = {
#     "html": {
#         "head": {
#             "title": "Мой сайт"
#         },
#         "body": {
#             "h1": "Здесь будет мой заголовок",
#             "div1": "Тут, наверное, какой-то блок",
#             "р": "А вот здесь новый абзац"
#         }
#     }
# }
#
#
# def find_key(struct, key):
#     if key in struct:
#         return struct[key]
#
#     for sub_struct in struct.values():
#         if isinstance(sub_struct, dict):
#             result = find_key(sub_struct, key)
#             if result:
#                 break
#     else:
#         result = None
#
#     return result
#
#
# user_key = input("Какой ключ ищем: ")
# value = find_key(site, user_key)
#
# if value:
#     print(value)
# else:
#     print("Такого ключа в структуре нет.")
# endregion Задача Код сайта.
# region Практика.
# region Задача 1. Challenge
# Обычно программисты любят, когда всё просто и понятно. Но Антон не из таких. Он любит устраивать себе челлендж,
# развиваться и сразу применять на практике то, что только что узнал. И в этот раз он подумал реализовать подсчёт
# факториала без использования циклов.

# Напишите функцию, которая считает факториал числа с помощью рекурсии.

# Кстати, в Python есть ограничение на количество рекурсивных вызовов. Попробуйте передать своей функции, например,
# число 1000 и посмотрите, что будет.

# import math
#
#
# def rec_factorial(number):
#     if number <= 1:
#         return 1
#     else:
#         return number * rec_factorial(number - 1)
#
#
# n = 5
# print(rec_factorial(n), math.factorial(n), rec_factorial(n) == math.factorial(n))

# endregion Задача 1. Challenge
# region Задача 2. Степень числа
# На одном из форумов, посвящённых программированию, пользователь выложил такой код для расчёта степени числа без
# использования циклов, ** и функции math.pow():

# def power(a, n):
#     if n <= 0:
#         return 1
#     else:
#         return a * power(a, n - 1)
#
# float_num = float(input('Введите вещественное число: '))
# int_num = int(input('Введите степень числа: '))
#
# print(float_num, '**', int_num, '=', power(float_num, int_num))


# Другие пользователи отметили, что это решение нерабочее и в нём есть ошибки. Исправьте это решение, не используя
# циклы, возведение в степень через ** и функцию math.pow()

# Правильный результат:
# Введите вещественное число: 1.5
# Введите степень числа: 5
# 1.5 ** 5 = 7.59375
# endregion Задача 2. Степень числа
# endregion Практика.
# endregion 8.2 Функция - Рекурсия.
# region 8.3 Подробнее о рекурсии.
# region Общие понятия.
# В первую очередь надо понять, что рекурсия не использует новые инструменты и незнакомые особенности языка.
# Если откинуть лишнее, то рекурсия — это просто вызов функции.
#
# Привычная простая функция без рекурсии:
#
# def foo(x):
#      print(x)
#
# Функция с рекурсией:
#
# def foo(x):
#      foo(x)
#
# Первая функция распечатает x, вторая будет бесконечно вызывать себя же и вызовет исключение. Результат их работы
# разный, но принцип — одинаковый.
# Первая функция распечатает x, вторая будет бесконечно вызывать себя же и вызовет исключение. Результат их работы 
# разный, но принцип — одинаковый. 

# И там, и там функция foo вызывает новую функцию (в первом случае print, во втором — foo). 

# И там, и там python приостановит выполнение текущей функции foo, чтобы полностью выполнить вызов вложенной функции, 
# а после завершения — продолжит выполнение текущей функции. 

# И там, и там, когда python дойдёт до выполнения print(x) или foo(x), он возьмёт имя переменной (print или foo) и 
# будет искать в памяти то, что хранится под этими именами. Далее найдёт функцию, а внутри функции найдёт код и 
# выполнит его. Python не различает, та же самая это функция или новая, он просто видит имя функции и выполняет код
# внутри этой функции.
#
# Система с приостановлением выполнения текущей функции для выполнения новой называется стеком вызовов и работает
# примерно так:

# Пример с простой функцией:
# def foo(x):
#     print(x)
#
# foo(5)

# python доходит до вызова foo(5) и foo(5), помещается внутрь стека вызовов.

# Далее python выполняет код функции, которая находится на вершине стека (у нас в стеке сейчас одна функция,
# она и выполняется).

# Внутри функции python встречает вызов другой функции:
# print(x)

# Она тоже добавляется в стек.

# Сразу две функции python выполнять не может, поэтому foo(5) приостанавливается, а print(5) запускается
# (запускается всегда та функция, которая выше в стеке вызовов).

# Код внутри print(5) выполняется, число 5 выводится на консоль, функция print завершается и, при завершении,
# удаляется из стека.

# Управление возвращается к функции foo(5).
# Так как кода в этой функции больше нет, то и foo(5) завершается и удаляется из стека.

# Таким образом стек помогает python создать очередь из функций, которые надо выполнить. Только, в отличие от обычной
# очереди, то, что пришло раньше всего (foo(5) в нашем примере), уйдёт позже всего (foo(5) будет полностью выполнен
# только после того как будет выполнена функция print). Вот такая несправедливая очередь получается. Кто позже пришёл
# — тот быстрее выполняется.
# endregion Общие понятия.
# region Стек вызова функции
# Как это поможет разобраться с рекурсиями?

# Давайте разберём тот же пример со стеком с рекурсией. Только немного изменим пример, чтобы наша рекурсия не вызывала
# исключения, а завершалась, спустя несколько повторных вызовов.
#
# Пример:
# def foo(x):
#     if x <= 0:
#         print(x)
#     else:
#         foo(x - 1)
#
#
# foo(3)

# Тут у нас есть блок if, который поможет завершить вызовы новых рекурсий.
# У нас есть два варианта действий.
# Если x равен 0, то мы выполняем простой принт.
# Если x не равен 0, то мы вызываем рекурсию с x, значение которого уменьшено на 1.
# В итоге, если мы передадим в функцию 3, то функция вызовет себя же с числом 2, потом ещё раз вызовет себя же с
# числом 1, ещё раз вызовет себя с нулевым значением, и все вызовы будут завершены.
# Как это выглядит изнутри:
# foo(3) — стартует оригинальный вызов.
# Внутри выполняется проверка 3 <= 0?
# Если ответ false, то сработает код в else.
# foo(3-1) → python сперва посчитает 3-1, получит 2 и запустит → foo(2).
# foo(2) запустит проверку 2 <= 0?
# Опять ответ будет false,
# значит сработает else и вызов
# foo(2-1) → foo(1)
# foo(1) запустит проверку 1<= 0?
# Будет false, сработает else.
# foo(1-1) → foo(0)
# foo(0) запустит проверку 0<= 0? Наконец-то ответ true!
# Значит, else не сработает и следующего вызова не будет!
# Сработает функция print(0), которая, опять же, будет добавлена в стек.
# Вот так мы заполнили несправедливую очередь функциями, дали pythonу много работы, и он начинает (правильнее будет
# сказать, «продолжает») выполнять эти функции с самой верхней — с принта.
# Выполняется принт: 0 выводится в консоль, функция завершается, принт удаляется из стека.
# Управление возвращается к foo(0).
# На чём мы остановились?
# def foo(x):
#     if x <= 0:
#         print(x) — этот принт выполнился как  else:
#
#         foo(x-1)  вот сюда.

# Else не сработает. Если сработал if, то выполнение кода переходит на строку «вот сюда». Кода в функции больше нет,
# а значит функция завершается и удаляется из стека.

# *Интересный факт: если бы после if/else был ещё какой-то код, то он бы выполнился после срабатывания принта. То есть
# функция выполнила бы часть кода до другой функции, остановилась бы на время выполнения вложенной функции, а, по
# возвращении к работе, — выполнила бы остальную часть кода.

# После завершения и удаления foo(0) из стека, он выглядит так:
# Теперь python возвращается к функции foo(1).
# В ней тоже нет кода, который нужно выполнить, поэтому функция просто завершается.

# Мы называем его оригинальным, потому что он был вызван изначально, а остальные вызовы были начаты рекурсивно.
# python возвращается к этой функции, смотрит, есть ли ещё код, который надо выполнить в этой функции.
# Если не находит кода, то функция завершается и удаляется из стека, оставляя его полностью пустым.
# Очень важно продумывать условие выхода из рекурсии, иначе она будет работать бесконечно, и python вызовет ошибку,
# чтобы она не съела всю память вашего компьютера.

# Таким образом, при помощи стека мы можем проследить всю цепочку «жизни» рекурсии и увидеть, что вся эта цепочка —
# повторяющийся вызов функций. Значит, рекурсия — это не новый инструмент, а, скорее, новый способ использования уже
# знакомых функций.
# endregion Стек вызова функции
# region Вернуть результат рекурсии — невыполнимо?
# Если это так, то с вызовами рекурсии работают те же правила, что и с вызовами обычных функций.

# В примере мы передавали в каждый новый вызов новое число, чтобы каждый новый вызов сработал иначе. Так мы делаем и с
# обычными функциями, выполняя повторяющийся код с новыми значениями переменных.

# Но что делать, если мы захотим вернуть значение из рекурсии?

# В первую очередь, нужно вспомнить, как возврат работает с обычными функциями. return возвращает какой-либо объект в
# место, в котором была запущена функция.

# Если мы создадим функцию:
# def sum_test(x, y):
#     return x + y

# и вызовем её:
# result = sum_test(1, 2)
# print(result)

# то python:
# найдёт по названию объект sum_test;
# поймёт, что это функция;
# создаст переменные x=1 и y=2;
# посчитает сумму x+y с этими переменными;
# вызовет return с получившимся ответом;
# в итоге число, которое мы передали return, заменит вызов функции;
# то есть sum_test(1, 2) будет заменён на число 3;
# значит:
# result = sum_test(1, 2),
# теперь будет
# result = 3.

# В конце переменная будет распечатана в консоль.
# Функция вернула своё значение именно в ту строку, в которой была вызвана.
# Попробуем выполнить то же самое с рекурсией:
# def foo(x):
#     if x <= 0:
#         return 0
#     else:
#         new_result = foo(x - 1)
#         result = x + new_result
#         return result

# По задумке функция будет получать число x (пусть оно будет целым и положительным) до тех пор, пока оно больше 0 — мы
# будем вызывать рекурсивный вызов этой функции с x, уменьшенным на 1.

# То есть, если вызвали foo(2), то рекурсивно будут вызваны сначала foo(1), а потом — foo(0).
# Чтобы лучше проследить весь путь рекурсии, добавим принты!


# def foo(x):
#     if x == 0:
#         print("Вызов foo(0) возвращает 0")
#         return 0
#     else:
#         print(f"Вызов foo({x - 1}) начинается и добавляется в стек")
#         new_result = foo(x - 1)
#         print(f"Вызов foo({x - 1}) завершился и удаляется из стека")
#         result = x + new_result
#         return result
# 
# print(f"Вызов foo(2) начинается и добавляется в стек")
# result = foo(2)
# print(f"Вызов foo(2) завершается и удаляется из стека")
# print("Итоговый ответ — ", result)

# При запуске мы получим такой вывод в консоль:
# Вызов foo(2) начинается и добавляется в стек.
# Вызов foo(1) начинается и добавляется в стек.
# Вызов foo(0) начинается и добавляется в стек.
# Вызов foo(0) возвращает 0.
# Вызов foo(0) завершился и удаляется из стека.
# Вызов foo(1) завершился и удаляется из стека.
# Вызов foo(2) завершается и удаляется из стека.
# Итоговый ответ — 3.

# Мы можем увидеть сходство с прошлым примером.
# Сперва стек заполняется вызовами foo(2), foo(1), foo(0).
# Затем foo(0) завершается.
# python начинает выполнять все приостановленные функции:
# сначала foo(1),
# потом foo(2).

# Этот элемент является важным в примере:
# new_result = foo(x - 1).

# Мы рекурсивно вызываем функцию с числом, уменьшенным на 1, и записываем результат выполнения этой функции в
# переменную new_result.

# Если бы мы написали что foo(x-1), то результат бы посчитался, вернулся, но не был бы сохранён в переменную и в итоге
# был бы потерян. Часто делают эту ошибку, думая, что return завершает сразу все вызовы рекурсии и отправляет ответ в
# то место, где была вызвана оригинальная функция «снаружи». Но это не так.

# Если бы мы вызывали другие функции с return внутри нашей функции, то их return не завершил бы нашу. Это логично, ведь
# мы сами хотим завершить её, когда получим нужный ответ.

# Например:
# def sum_test(x, y):
#     return x + y

# def test_return(a, b, c):
#     new_summ = sum_test(a, b) — вызывая эту функцию, мы хотим получить промежуточный результат; мы не хотим, чтобы
#     наша функция завершилась;
#     result = new_summ + c — получив результат вложенной функции, мы его изменяем
#  и возвращаем (return result).

# value = test_return(1, 2, 3)
# В итоге в value будет записано то число, которое попало в return result, но ни в коем случае не то число, которое
# вернулось при помощи return x+y.

# Так и с рекурсией: каждый вложенный вызов делает промежуточные расчёты, которые мы МОЖЕМ (если захотим) сохранить и
# использовать в наших дальнейших расчётах.

# Рассмотрим нашу функцию подробнее:
# def foo(x):
#     if x <= 0:
#         return 0
#     else:
#         new_result = foo(x - 1)
#         result = x + new_result
#         return result

# print(foo(2))

# Запускается foo(2).
# Срабатывает else, так как 2 больше 0.
# python начинает выполнять первую строку внутри else:
# new_result = foo(2-1).
#
# В этой строке у нас целых три действия.
#
# 2-1
# foo(1)
# new_result =
# И, что интересно, python выполнит первое действие и посчитает 2-1.
# Это нужно, чтобы запустить функцию foo(1). Но после запуска функция foo(2) будет поставлена на паузу, и действие
# new_result = будет выполнено после того, как завершится действие foo(1). Следующие строки тоже не будут выполнены,
# пока функция foo(2) приостановлена!

# Идём дальше. Запускается foo(1).
# Опять срабатывает else, так как 1 больше 0.

# python доходит до строки:
# new_result = foo(1-1)
# Выполняет foo(1-1) → foo(0).

# Теперь функция foo(1) тоже приостановлена!
# Управление переходит к foo(0).
# Срабатывает условие if x<= 0, так как 0 равен 0.
# Срабатывает return 0.
# И этот return:

# завершает работу функции foo(0);
# возвращает число 0 туда, где была вызвана функция foo(0), а значит возвращает 0 в вызов foo(1).
# python снимает с паузы функцию foo(1)
# и продолжает с того места, на котором остановился:
# new_result = 0;
# result = 1+0  (x в текущем вызове по-прежнему равен 1);
# return 1 — этот return завершает функцию foo(1).

# Функция foo(1) удаляется из стека, а python снимает с паузы оригинальный вызов foo(2).

# Снова выполнение продолжается с того места, на котором мы остановились:

# new_result = 1 — тут мы вызывали foo(1); выше мы посчитали, что результат foo(1) был равен числу 1;
# result = 2+1  (x в текущем вызове по-прежнему равен 2);
# return 3 — этот return завершает функцию foo(2).

# Из стека удаляется функция foo(2),
# а результат её выполнения попадает в строку, в которой была вызвана эта функция:
# print(foo(2)) — то есть сюда.

# И, наконец, мы распечатываем число 3 :)

# Ещё один важный момент — визуализация.
# Пониманию рекурсии (и других сложных идей) очень помогает «подключение» органов чувств. В нашем случае можем
# использовать визуальную информации о ходе выполнения рекурсивного алгоритма.
# Есть хороший пример — рисование дерева при помощи рекурсии.

# Если мы будем рисовать функцией одну ветвь, а в конце функции вызывать себя же дважды (чтобы нарисовалось две ветви
# из конца одной), то получим что-то подобное:

# В видео возможно упоминание Инстаграм и Фейсбук. Деятельность компании Meta Platforms Inc., которой принадлежит
# Инстаграм / Фейсбук, запрещена на территории РФ в части реализации данных социальных сетей на основании осуществления
# ею экстремистской деятельности

# Дерево — очень хорошая метафора. Каждая ветвь на рисунке — это один вызов функции. Мы можем проследить, какой вызов
# откуда начался и в какой момент эти вызовы заканчиваются. Например, если мы в условии выхода из рекурсии поставим
# определённый размер ветви (каждый раз ветвь немного уменьшается; мы можем перестать рисовать ветви, если они станут
# меньше указанного размера), то такое условие обрежет часть ветвей, и мы наглядно увидим, как сократилось количество
# вызовов.

# Кроме того, интересной может быть работа с параметрами. Каждый вызов должен получить точку, из которой рисуется ветка.
# Если во все вызовы передавать начальную точку, то у нас получится странный куст. Чтобы получилось дерево, нужно в
# конце вызова передавать следующим веткам текущую точку, в которой закончилась ветка текущего вызова. И на практике,
# при использовании рекурсий, зачастую надо в каждый новый вызов передавать новые параметры. Так, в нашей прошлой
# задаче, мы передавали x в каждый новый вызов, уменьшая его на единицу. В итоге каждый вызов функции обрабатывал своё
# значение x, а когда приходила очередь нуля, рекурсия завершалась.

# Больше примеров визуализации вы найдете по ссылкам ниже:

# Recursion Visualization - Algorithms (англ.)
# Ссылка на инструмент, с которым вы можете самостоятельно визуализировать свои функции, но на другом языке
# программирования. Можно подогнать свой код под него или воспользоваться другим ресурсом.
# endregion Вернуть результат рекурсии — невыполнимо?
# endregion 8.3 Подробнее о рекурсии.
# region 8.4 Передача изменяемых и неизменяемых данных в функцию
# region Практика
# region Задача 1. Ошибка
# В одном проекте на 10 000 строк кода произошла критическая ошибка. Хорошо, что старший разработчик быстро её нашёл и
# исправил. Он решил проверить, смогли бы вы её исправить, если бы его не было на месте. Поэтому он написал для вас код
# с аналогичной ошибкой:

# import random
#
#
# def change_dict(dct):
#     num = random.randint(1, 100)
#     for i_key, i_value in dct.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)
#
#
# nums_list = [1, 2, 3]
# some_dict = {1: 'text', 2: 'another text'}
# uniq_nums = {1, 2, 3}
# common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
#
# change_dict(common_dict)
# print(common_dict)



# Суть кода в том, что у вас есть общий словарь из нескольких ключей, значения которых равны ранее объявленным
# переменным. Затем вызывается функция, которая должна изменять значения словаря, добавляя к значениям случайное число,
# в зависимости от типа данных. Но при этом меняются и ранее объявленные переменные. Исправьте эту ошибку и убедитесь,
# что nums_list, some_dict и uniq_nums не меняются.
# import random
#
#
# def change_dict(dct):
#     num = random.randint(1, 100)
#     for i_key, i_value in dct.items():
#         if isinstance(i_value, list):
#             i_value.append(num)
#         if isinstance(i_value, dict):
#             i_value[num] = i_key
#         if isinstance(i_value, set):
#             i_value.add(num)
#
#
# nums_list = [1, 2, 3]
# some_dict = {1: 'text', 2: 'another text'}
# uniq_nums = {1, 2, 3}
# # Решить это задание можно разными способами
# # Мы можем вручную копировать каждый входящий элемент:
# common_dict = {1: nums_list.copy(), 2: some_dict.copy(), 3: uniq_nums.copy(), 4: (10, 20, 30)}
# change_dict(common_dict)
# print(common_dict)
# # Либо мы можем применить вспомогательную функцию, которая сделает это за нас:
# import copy
#
# common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
# common_dict_2 = copy.deepcopy(common_dict)  # Она будет особенно полезна в структурах,
# # в которых множество вложенных переменных
# change_dict(common_dict_2)
# print(common_dict_2)
#
# print(nums_list, some_dict, uniq_nums)

# endregion Задача 1. Ошибка
# region Задача 2. Непонятно!
# Друг никак не может понять эту тему с изменяемыми и неизменяемыми типами, ссылками, объектами и их id. Видя, как он
# мучается, вы решили помочь ему и объяснить эту тему наглядно.
#
# Пользователь вводит любой объект. Напишите программу, которая выводит на экран тип введённых данных, информацию о его
# изменяемости, а также id этого объекта.

# Пример 1:
# Введите данные: привет
# Тип данных: str (строка)
# Неизменяемый (immutable)
# Id объекта: 1705156583984

# Пример 2:
# Введите данные: {‘a’: 10, ‘b’: 20}
# Тип данных: dict (словарь)
# Изменяемый (mutable)
# Id объекта: 1705205308536

# region Решение SkillBox
# data_names_dict = {"<class 'str'>": "строка",
#                    "<class 'dict'>": "словарь",
#                    "<class 'list'>": "список",
#                    "<class 'set'>": "множество"}
#
# mutable_check_helper = {"mutable": ("словарь", "список", "множество")}
#
#
# def check_info(data):
#     type_of_data = type(data)
#     name_of_data = ""
#     if str(type_of_data) in data_names_dict:
#         name_of_data = data_names_dict[str(type_of_data)]
#
#     if name_of_data in mutable_check_helper["mutable"]:
#         property_of_data = "Изменяемый (mutable)"
#     else:
#         property_of_data = "Неизменяемый (immutable)"
#
#     print(f"Тип данных: {type_of_data} ({name_of_data})")
#     print(property_of_data)
#     print("Id объекта:", id(data))
#
#
# data_in = {"a": 10, "b": 20}
# print(f"Введенные данные: {data_in}")
# check_info(data_in)
# endregion Решение SkillBox
# endregion Задача 2. Непонятно!
# endregion Практика
# endregion 8.4 Передача изменяемых и неизменяемых данных в функцию
# region 8.5 Передача данных в функцию
# region Что такое переменные
# Перед тем как приступить к рассмотрению изменяемых и неизменяемых типов данных, стоит вникнуть в работу Python с
# переменными, которая выполняется «под капотом».

# Для начала возможный шок-контент: если мы напишем x = 5, то это совершенно не значит, что х хранит в себе число 5.

# Число 5 «физически» хранится на диске, а переменная с названием x содержит только ссылку на ту область памяти, в
# которой хранится это число. Например, число 5 записано в ячейку памяти №123.

# Если мы напишем
# x = 5
# и
# y = x,
# то и х и y будут хранить адрес ячейки памяти №123, и, только пройдя по этой ссылке,  Python сможет узнать информацию о
# типе объекта и его содержании.

# Так, например, происходит, когда мы пытаемся выполнить над переменной действие, которое нельзя выполнить с объектом,
# на который ссылается переменная.

# Например, нельзя вызвать число как функцию:
# x = 5
# x() — Python даст выполнить эту строку.
# TypeError: 'int' object is not callable — но при выполнении вызовет ошибку.

# Кстати, если мы изменим переменную x после этого:
# x = 10
# то переменная y продолжит ссылаться на число 5,
# а переменная x будет ссылаться на число 10,
# то есть, когда мы пишем y = x, это значит, что мы добавляем в переменную y такую же ссылку, какая была в переменной x.
# Но дальше эти переменные не будут зависеть друг от друга.

# Из этого всего стоит запомнить три понятия:

# Переменная — по сути, это имя,
# объекты — это области памяти для хранения значений,
# ссылки — указатели от имени к области памяти.
# endregion Что такое переменные
# region Работа с объектами. Начало
# Что происходит с объектами посложнее?

# L1 = [22, 33, 44]
# L1 будет именем, которое содержит указатель на область памяти со списком,
# но числа внутри списка — это тоже отдельные объекты, которые хранятся в своих ячейках.

# Если мы напишем
# L2 = L1,
# то создадим ещё одно имя, которое будет ссылаться на этот же список.

# Если мы напишем
# L1[0] = 55,
# то, по сути, мы изменим ссылку на объект, который был внутри списка на первом месте.

# Если мы проверим после этого, что хранится в L2, то увидим те же самые числа:
# [55, 33, 44],
# так как L1[0] = 55 изменило не сам список, а объект внутри списка.

# Такое поведение характерно для изменяемых объектов вроде списков или словарей. Это их особенность, которой можно и
# нужно пользоваться. Но правильно её использовать можно, только если вы знаете, как оно работает изнутри.

# endregion Работа с объектами. Начало
# region Работа с объектами. Продолжение
# С неизменяемыми объектами сделать так не получится.
# Например:
# x = (1, 2, 3)
# x[0] = 5 — попытка изменения кортежа приведёт к ошибке:
# TypeError: 'tuple' object does not support item assignment

# Но это не значит, что неизменяемые объекты хуже. Так как они не поддерживают такой довольно сложный механизм, они
# затрачивают меньше памяти на хранение тех же самых данных.

# import sys
#
# test_list = list()
# test_tuple = tuple()
# print(sys.getsizeof((test_list)))
# print(sys.getsizeof((test_tuple))) # кортеж будет весить меньше.

# Вернёмся к изменяемым объектам.
# Что делать, если мы захотим получить отдельный список в новую переменную?
# Нам поможет копирование.
# Сделать это можно разными способами.
# L2 = L1[:] — популярный метод копирования, при котором мы, по сути, создаём новый объект из среза со всеми элементами
# старого списка.
# В итоге L2 будет ссылаться уже на новый список, не связанный с оригинальным списком L1.
# Такой приём сработает со списками, но не сработает, например, со словарями (у него и индексов нет для среза).
# Поэтому более универсальный способ — использование метода copy().

# dist = {1: 2, 3: 4}
# x = dist.copy()
# x[1] = 5
# print(x, dist) — значение по ключу 1 будет разным в этих двух объектах.

# Сам метод встроен в объекты, поэтому можно использовать его напрямую, но также существует и подключаемая стандартная
# библиотека copy.
# Ссылки на официальную документацию и русский сайт с примерами работы с этой библиотеки:
# copy — Shallow and deep copy operations (англ.)
# Модуль copy — поверхностное и глубокое копирование объектов
# Использовать её можно так:
# import copy
# dist = {1: 2, 3: 4}
# x = copy.copy(dist)
# x[1] = 5
# print(x, dist)

# По сути, эти вызовы будут эквивалентны (разве что в первом варианте будет меньше символов). Но в модуле copy есть ещё
# одна полезная функция, которая называется deepcopy.

# Чтобы понять всю её прелесть, надо сперва поговорить о сложных составных структурах данных.

# Это те структуры, которые хранят в себе не просто числа, как в примерах выше, а другие структуры данных. Например,
# список списков:
# list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]

# или словарь списков:
# dict_of_lists = {1: [1, 2, 3], 2: [4, 5, 6]}

# (Кстати, попробуйте использовать список в качестве ключа у словаря — вылезет ошибка, которая скажет вам о том, что
# изменяемые типы данных не могут быть использованы в качестве ключей.)

# В целом, структура может быть совершенно любой комбинацией, так как каждый вложенный список/словарь и тому подобное
# может хранить в себе другие вложенные списки/словари и тому подобное.

# Эта особенность настолько удобна и популярна, что, по сути, выросла в отдельный формат данных — JSON. Этот формат
# очень распространён и используется практически со всеми языками программирования, а суть его проста: в словаре
# хранятся ключи и значения, значениями могут быть другие словари/списки/строки/числа…

# И это позволяет собирать информацию хоть и в сложные, но понятные и хорошо структурированные блоки данных.
# endregion Работа с объектами. Продолжение
# region Работа с вложенными объектами
# Но при работе с подобным мощным инструментом стоит помнить и о его особенностях.
#
# Важно понять, какую роль играют ссылки в структуре такого объекта.
#
# list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
#
#
# Автор Максим Л.В
#
# list_of_lists будет ссылаться на оригинал, у которого внутри есть ссылки на три любых объекта.
#
# Первая ссылка будет ссылаться на другой список, у которого внутри тоже лежат три ссылки которые, в свою очередь,
# ведут к числам 1, 2 и 3.
#
# Вторая ссылка ведёт к числу 4.
#
# Третья ссылка ведёт к списку с тремя ссылками внутри, а они ведут к числам 5, 6, 7.
#
# Обращение к элементам.
# По сути, нам надо выстраивать цепочку из ссылок:
# list_of_lists[0] — ссылка на первую ссылку внутри списка.
# list_of_lists[0][0] — ссылка на число внутри списка, который лежит внутри оригинального списка.
#
# Если мы напишем
# list_of_lists[0][0] = 10,
# то эти изменения будут отражены в каждом объекте, который ссылался на список внутри list_of_lists.
#
# С текущим примером всё легко, но это также значит, что вложенный список может быть и в других списках.
#
# Например, мы можем вынести один простой список в переменную:
#
# x = [1, 2, 3].
#
# list_of_lists = [x, 4, [5, 6, 7]] — а дальше добавлять его в другие списки через переменную.
#
# list_of_lists_2 = [x, [8], [9, 10, 11]]
#
# list_of_lists[0][0] = 10 — изменив элемент в этом списке:
#
# print(x, list_of_lists_2, list_of_lists, sep='\n'), мы увидим, что это изменение коснулось и x, и list_of_lists_2.
#
# Похожая особенность касается и копирования.
# Сперва давайте определимся с тем, что такое копирование — copy().
# По сути, это создание объекта с теми же вложенными объектами.
#
# В Python copy() буквально копирует объект, и, если в объекте есть ссылки, они тоже копируются.
#
# list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
# list_of_lists_2 = list_of_lists.copy()
#
#
# Автор Максим Л.В
#
# Возможно, вы уже увидели проблему, которая кроется в таком подходе.
# list_of_lists[0][0] = 10 — изменение во вложенном списке.
# print(list_of_lists)
# print(list_of_lists_2)
# [[10, 2, 3], 4, [5, 6, 7]]
# [[10, 2, 3], 4, [5, 6, 7]] — будут отражаться и в копии списка, так как копия имеет точно такие же ссылки, какие были
# в оригинале.
# В итоге мы как будто получаем не полную копию, а только поверхностную копию списка.
#
# Именно эту проблему решает функция deepcopy из модуля copy.
#
# list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
# list_of_lists_2 = copy.deepcopy(list_of_lists)
#
#
# Автор Максим Л.В
#
# list_of_lists[0][0] = 10
# print(list_of_lists)
# print(list_of_lists_2)
# [[10, 2, 3], 4, [5, 6, 7]]
# [[1, 2, 3], 4, [5, 6, 7]] — теперь изменения не отражаются в копии.
#
# Deepcopy, по сути, рекурсивно прошла по всем вложенным спискам и к каждому применила copy(), создав копии всех
# вложенных объектов.
# endregion Работа с вложенными объектами
# endregion # region 8.5 Передача данных в функцию
# region 8.6 Именованные аргументы и значения по умолчанию
# region Практика
# region Задача 2 Накопление значений
# При работе со значениями по умолчанию и изменяемыми типами данных нужно знать и остерегаться ещё одной интересной
# штуки.

# Напишите функцию с двумя аргументами: первый — число num, позиционный аргумент; второй — список lst, по умолчанию он
# пустой. В теле функции в список добавляется число num и сам список выводится на экран.

# В основной программе вызовите функции три раза только с одним аргументом (числом), например так:

# add_num(5)
# add_num(10)
# add_num(15)

# И посмотрите, что произойдёт.

# После этого сделайте значение lst по умолчанию None и поправьте функцию, чтобы она работала правильно.


# def add_num(num, lst = []):
#     lst.append(num)
#     print(lst)
#
# add_num(5)
# add_num(10)
# add_num(15)
#
# def add_num(num, nums=None):
#     nums = nums or []
#     # хитрая конструкция, которая позволит упростить ввод:
#     if not nums:
#         nums = []
#     # Первый вариант будет выбран, если nums не равен None, иначе будет создан и записан пустой список
#         nums.append(num)
#     print(nums)
#
#
# add_num(5)
# add_num(10)
# add_num(15)
# endregion Задача 2
# region Задача 3 Помощь другу.
# Нашего друга попросили написать функцию, которая на вход принимает список всякого мусора. Ему нужно подготовить из 
# этого списка список словарей, чтобы его коллеги смогли дальше продолжить обработку данных. Вот список правил, что 
# нужно сделать с изначальным списком:

# Если в списке встретился словарь, то оставляем его.
# Если в списке встретилась строка, то из неё нужно сделать словарь и положить его в итоговый список, например  'abc' → 
# {'abc': 'abc'}.

# С числами нужно сделать то же самое, что и со строками.
# Всё остальное выкидываем из нашего списка.

# Друг написал программу, но в ней ошибка, так как она что-то не то выводит :( Нужна ваша помощь, вот сама программа: 
# def create_dict(data, template=dict()):
#     if isinstance(data, dict):
#         return data
#     if isinstance(data, int) or isinstance(data, float) or isinstance(data, str):
#         return template[data] = data
#
# def data_preparation(old_list):
#     new_list = []
#     for i_element in old_list:
#         new_list.append(create_dict(i_element))
#     return new_list
#
# data = ['sad', {'sds': 23}, {43}, [12, 42, 1], 2323]
# data = data_preparation(data)
# print(data)
#
# Решение
# def create_dict(data, template=None):
#     if isinstance(data, dict):
#         return data
#     elif isinstance(data, (int, float, str)):
#         template = template or dict()
#         template[data] = data
#         return template
#     else:
#         return None
#
#
# def data_preparation(old_list):
#     new_list = []
#     for i_element in old_list:
#         new_elem = create_dict(i_element)
#         if new_elem:
#             new_list.append(new_elem)
#     return new_list
#
#
# data = ["sad", {"sds": 23}, {43}, [12, 42, 1], 2323]
# data = data_preparation(data)
# print(data)

# Исправьте программу и убедитесь, что всё работает верно.
# endregion Задача 3 Помощь другу.
# endregion Практика
# endregion 8.6 Именованные аргументы и значения по умолчанию

