# Cловарь - это набор объектов, доступ к которым осуществляется не по индексу, а по ключу (аналог ассоциативных
# массивов в РНР). Словари могут содержать данные разных типов и иметь неограниченную степень вложенности.

# Элементы в словарях находятся в произвольном порядке. Для доступа к элементу нужно использовать ключ, нет никакого
# способа обратиться к элементу в порядке добавления.

# Словари, как тип данных, относятся не к последовательностям, а к отображениям. Именно поэтому операции, которые были
# применимы к последовательностям (конкатенация, повторение, срез и т.д.), к словарям неприменимы.

# Существует несколько способов создания словаря. Первый способ - это использование функции dict().
# dict( <Ключ 1 > = <Значение 1> [ , ... , <КлючN>=<ЗначениеN>]
# diсt(<Список кортежей с двумя элементами - Ключ и Значение>)
# diсt(<Список списков с двумя элементами - Ключ и Значение>)

# Рассмотрим несколько примеров:

# # Первый оператор создает пустой словарь
# d = dict()
# print(d)    # {}
#
# # Второй - создает словарь по парам Ключ=Значение.
# d = dict(name='Ивaн', surname='Ивaнoв')
# print(d)    # { 'name': 'Иван', 'surname': 'Иванов'}
#
# # Третий оператор - создает словарь по словарю, да и в качестве параметров функции dict()
# # мы передали уже готовый словарь.
# d = dict[str, str]({"name": "Иван", "surname": "Иванов"})
# # print(d)    # { 'name' : 'Иван' , 'surname' : 'Иванов' }
#
# # Четвертый оператор создает словарь по списку списков.
# d = dict[str, str]([["name", "Иван"], ["surname", "Иванов"]])
# print(d)    # { 'name': 'Иван', 'surname': 'Иванов'}
#
# # Пятый по списку кортежей.
# d = dict([("name", "Иван"), ("surname", "Иванов")])
# print(d)    # { 'name': 'Иван', 'surname': 'Иванов'}

# -------------
# Как видите, существуют различные способы создания·словарей, и вы можете выбрать тот, который вам больше нравится.
# В создании словаря может участвовать и функция zip(). Она может объединить два списка в список кортежей.
# Например:

# # У нас есть два списка - keys (ключи) и values (значения).
# keys = ("name", "surname")
# values = ("Иван", "Иванов")
#
# # Мы комбинируем их функцией zip
# list(zip(keys, values))  # [ ('name', 'Иван'), ('surname', 'Иванов')]
#
# # и создаем общий список kv.
# kv = list(zip(keys, values))
#
# # потом передаем в функцию dict и получаем такой же словарь, как и раньше.
# d = dict(kv)
# print(d)    # {'name': 'Иван', 'surname': 'Иванов'}
#
# # Также создать словарь можно, заполнив его поэлементно, например:
# d = {}
# d["name"] = "Иван"
# d["surname"] = "Иванов"
# print(d)    # {'name': 'Иван', 'surname': 'Иванов'}

# # Если вам удобно, вы можете указать все элементы словаря в фигурных
# # скобках:
# d = {}
# d = {"name": "Иван", "surname": "Иванов"}
# print(d)    # {'name': 'Иван', 'surname': 'Иванов'}

# При создании словаря нужно помнить, что в переменную сохраняется не сам словарь, а только ссылка на него,
# что нужно учитывать при групповом присваивании. Если вам нужно скопировать словарь, то вам нужно использовать
# не оператор присваивания, а метод сору(). Рассмотрим пример:

# d = {"name": "Иван", "surname": "Иванов"}
# print(d)    # { 'name' : 'Иван' , 'surname' : 'Иванов' }
# d2 = d
# print(d2 is d)  # True
# # Если присвоить d переменной d2, то оператор is сообщит, что обе переменные ссылаются на один и тот же объект
# # в памяти (True).
#
# # Если же скопировать словарь через метод сору(), то будет создана независимая копия в памяти
# # (оператор is вернет False)
# d2 = d.copy()
# print(d2 is d)  # False
#
# # Однако метод сору() делает только поверхностную копию словаря, для создания полной копии лучше использовать функцию
# # deepcopy():
# d2 = copy.deepcopy(d)   # {'name': 'Иван', 'surname': 'Иванов'}
# print(d2 is d)  # False

# ---------------------------------------------------------------------------------------------------------------------#
# 10.2. Различные операции над словарями.
# 10.2. 1. ДОСТУП К ЭЛЕМЕНТУ
# Начнем с доступа к элементу. Доступ осуществляется по ключу:
# d = {"name": "Иван", "surname": "Иванов"}
# print(d["name"])    # 'Иван'

# При обращении к несуществующему элементу будет сгенерировано исключение:
# >>> d["lastname"]
# Traceback (most recent call last): ·
# File "<pyshell#25>", line 1, in <module>
# d.[ "lastname"]
# KeyError: 'lastname'

# Проверить наличие ключа можно с помощью оператора in:
# print("surname" in d)   # True
# print("lastname" in d)  # False

# Узнать, сколько ключей есть в словаре можно с помощью функции len():
# print(len(d))  # 2

# 10.2.2. ДОБАВЛЕНИЕ И УДАЛЕНИЕ ЭЛЕМЕНТОВ СЛОВАРЯ
# Добавить элемент в словарь можно так:
# d = {'name':'Иван', 'surname':'Иванов'}
# d["lastname"] = "Иванов"
# print(d)    # {'name': 'Иван', 'surname': 'Иванов', 'lastname': 'Иванов'}

# Если ключ есть в словаре, то ему будем присвоено новое значение. Если ключа нет, то он будет добавлен в словарь.

# Удалить ключ из словаря можно с помощью оператора del:
# d = {'name': 'Иван', 'surname': 'Иванов', 'lastname': 'Иванов'}
# del d["lastname"]
# print(d)    # {'name': 'Иван', 'surname': 'Иванов'}

# 10.2.З. ПЕРЕБОР ЭЛЕМЕНТОВ СЛОВАРЯ
# # Перебрать все элементы словаря можно так:
# d = {'name': 'Иван', 'surname': 'Иванов', 'lastname': 'Иванович'}
# for key in d.keys():
#     print("({0} --> {1})".format(key, d[key]), end=" \n")
# # (name => Иван) (surname => Иванов)

# 10.2.4. СОРТИРОВКА СЛОВАРЯ
# Словарь - это неупорядоченная структура данных. Поэтому при выводе словаря его ключи выводятся в произвольном порядке.
# Вы же можете отсортировать словарь по ключам. Для этого нужно получить сначала список всех ключей, а затем
# использовать метод sort():

# keys = list(d.keys())
# keys. sort()
# for key in keys:
#     print("({0} --> {1})".format(key, d[key]), end="\n") # (name=> Иван) (surname=> Иванов)
# # Данный пример не очень удачен, поскольку и до сортировки ключи в словаре находились в отсортированном порядке
# # (так получилось), но если добавить в словарь новый элемент и повторить пример, все будет работать как
# # нужно:
# d["lastname"] = "Ивaнoв"
# d["zip"] = "109011"
# print(d)    # {'zip': '109011', 'lastname': 'Иванов', 'name': 'Иван', # 'surname': 'Иванов'}
# keys = list(d.keys())
# keys. sort ()
# for key in keys:
#     print("({0} --> {1})".format(key, d[key]), end=" ")
#     # (lastname=> Иванов) (name=> Иван) (surname=> Иванов) (zip=> 109011)

# 10.2.5. МЕТОДЫ KEYS(), VALUES() И НЕКОТОРЫЕ ДРУГИЕ.
# Метод keys(), как вы уже заметили, возвращает объект dict_keys, содержащий все ключи словаря.
# Данный объект поддерживает итерации, а также операции над множествами.
# Аналогично, метод values() возвращает объект dict_values, содержащий все значения словаря. Данный объект также
# поддерживает итерации. Пример:

# d = {'name': 'Иван', 'surname': 'Иванов', 'lastname': 'Иванович'}
# values = d.values()
# print(list(values))     # ['Иванов', 'Иван', 'Иванов'·]
# keys = d.keys()
# print(list(keys))   # ['name', 'surname', 'lastname']

# Также у словарей есть много дополнительных и бессмысленных методов.
# Например, метод get() возвращает значение элемента, но его и так можно получить:
# print(d.get("lastname"))      # 'Иванович'
# print(d["lastname"])     # 'Иванович'

# Особого cмысла в этом методе нет, как и в методе clear(), который очищает словарь.
# А вот метод рор() может пригодиться. Он удаляет элемент и возвращает его значение:
# d = {'name': 'Иван', 'surname': 'Иванов', 'lastname': 'Иванович'}
# d.pop("lastname")
# print(d)    # {'name': 'Иван', 'surname': 'Иванов'}

# -------------------------------------------------------------------------------------------------------------------- #
# ПРАКТИКА.
# 10.2.6. ПРОГРАММА DICT
# Продемонстрируем полученные знания на примере простой программы словаря.
# В этой программе мы будем активно использовать оператор in, чтобы выяснить, есть ли слово в словаре или нет:
# dic = {}
# if "bus" in dic:
#     print(dic["bus"])
# else:
#     print("Слова нет в словаре!")

# Поскольку при обращении к несуществующему элементу словаря генерируется ошибка,
# то перед обращением неплохо бы проверить его наличие с помощью оператора in. Напишем простейшую программу поиска
# по словарю.

# Листинг 10.1. Словарь v0.1
# dict = {"apple": "яблоко", "bold": "жирный", "bus": "автобус", "cat": "кошка", "car": "машина"}
# print("=" * 15, "Dict", "=" * 15)
# word = ""   # Сначала мы определяем переменную word
# while word != "q":  # Цикл while будет работать, пока эта переменная не равна "q".
#     word = input("Введите слово или q для выхода: ")    # Вводим слово.
#     if word != "q":     # Если слово не равно букве q
#         if word in dict:    # Ищем это слово по словарю.
#             print(dict[word])    # Если находим, то выводим его на экран.
#         else:       # Иначе...
#             print("He найдено")     # Выводим сообщение, что не найдено.

# Продолжим разработку нашего Словаря. Попробуем модифицировать исходную программу так, чтобы она поддерживала
# добавление и удаление элементов словаря, а также некоторые другие возможности.
# Листинг 10.2. Словарь v 0.1
# # Словарь заполнен по умолчанию
# dict = {"apple": "яблоко", "bold": "жирный", "bus": "автобус", "cat": "кошка", "car": "машина"}
# print("=" * 15, "Dict v 0-2", "=" * 15)
# # # Справка. Будет выведена по команде h
# help_message = """
# s - Поиск
# а - Добавить новое слово
# r - Удалить слово
# k - Показать все слова
# d - Показать весь словарь
# h - Справка
# q - Выход
# """
# choice = ""
# while choice != "q":
#     choice = input("(h - help)>> ")
#     if choice == "s":
#         word = input("Введите слово: ")
#         res = dict.get(word, "Не найдено!")
#         print(res)
#     elif choice == "a":
#         word = input("Введите слово: ")
#         value = input("Введите перевод: ")
#         dict[word] = value
#         print("Слово добавлено!")
#     elif choice == "r":
#         word = input("Введите слово: ")
#         del dict[word]
#         print("Слово удалено")
#     elif choice == "k":
#         print(dict.keys())
#     elif choice == "d":
#         for word in dict:
#             print(word, ": ", dict[word],)
#     elif choice == "h":
#         print(help_message)
#     elif choice == "q":
#         break
#     else:
#         print("Нераспознанная команда. Введите h для справки")

# -------------------------------------------------------------------------------------------------------------------- #
# 10.3. Понятие множества
# Множество - это неупорядоченный набор уникальных элементов. Вы можете проверить, входит ли тот или иной элемент в
# множество. Множество не может содержать два одинаковых элемента, все элементы множества уникальны.

# Создать множество можно с помощью функции set():
# s = set ()
# print(s)  # set ()

# Мы только что создали пустое множество. Однако функция set() может преобразовать во множество другие типы
# данных - строки, кортежи, списки. При преобразовании других типов данных помните, что во множестве останутся только
# уникальные элементы:

# # Строка
# s = set("Hello")
# print(s, "<-- Строка") # {'l', 'о', 'е', 'Н'}
#
# # Список
# print(set([1, 2, 3, 4, 5, 4]) , "<-- Список")      # { 1, 2, 3, 4, 5}
#
# # Кортеж
# print(set((1, 2, 3, 3, 4, 5)), "<-- Кортеж")  # {1, 2, 3, 4, 5}

# 10.4. . Операции над множеством
# Вот как можно перебрать элементы множества:
# s = {1, 2, 3, 4, 5}
# for i in s:
#     print(i, end=" ")
#
# # Узнать количество элементов во множестве можно с помощью функции
# print("\nКол-во элементов --> ", len(s))     # 5

# Но самое главное - не это. Прелесть множества в специальных операторах,
# предназначенных специально для множеств. Оператор | означает объединение множеств:

# s1 = {1, 2, 3}
# s2 = {3, 4, 5}
# s3 = s1 | s2
# print(s3)   # { 1, 2, 3, 4, 5}

# Обратите внимание, что при объединении множеств, в созданное множество попадают лишь уникальные элементы,
# что и продемонстрировано в этом примере.

# С помощью | можно добавить в одно множество элементы другого множества:
# s1 = {1, 2, 3}
# s2 = {3, 4, 5}
# s1 |= s2
# print(s1)   # {1, 2, 3, 4, 5}

# Оператор (-) означает разницу множеств:
# s1 = { 1, 2, 3, 4, 5}
# s2 = {3, 4, 5}
# print(s1 - s2)    # {1, 2}

# Оператор & - это пересечение множеств. Результат пересечения - это элементы, которые есть в обоих множествах:
# s1 = {1, 2, 3}
# s2 = {3, 4, 5}
# print(s1 & s2)  # {3}

# Оператор ^ возвращает элементы обоих множеств, исключая одинаковые
# элементы:
# print(s1 ^ s2)    # {1, 2, 4, 5}

# Оператор in обеспечивает проверку наличия элемента во множестве:
# s1 = { 1, 2, 3}
# print(3 in s1)    # True.
# print(4 in s1)    # False

# Оператор == обеспечивает проверку на равенство множеств:
# print(sl == s2)   # False

# Оператор s1 <= s2 проверяет, входят ли все элементы множества s1 во множество s2:
# s1 = # { 1, 2, 3}
# s2 = # { 3, 4, 5}
# print(sl <= s2) # False

# Оператор s1 < s2 проверяет, входят ли все элементы s1 во множество s2, но
# при этом сами множества не должны быть равны. Аналогично, есть операторы >= и >.

# 10.5. Методы множеств
# Множества поддерживают следующие методы:

# • add( <Элемент>) - добавляет <Элемент> во множество
# • remove( <Элемент>) - удаляет <Элемент> из множества
# • discard( <Элемент>) - удаляет указанный элемент из множества
# • рор() - удаляет произвольный элемент и возвращает его
# • clear() - очищает множество

# Методы remove() и discard() отличаются тем, что если указанный элемент
# отсутствует во множестве, то в первом случае будет возвращена ошибка, а
# во втором никаких сообщений не будет:

# s1 = {1, 2, 3}
# print(s1)
# s1.add(4)
# print(s1)
# s1.remove(4)
# print(s1)     # { 1, 2, 3}

# s1.remove(4)
# Traceback (most recent call last):
# File "<pyshell#lOO>", line 1, in <module>
# sl.remove(4)
# KeyError: 4
# >>> sl.discard(4) 