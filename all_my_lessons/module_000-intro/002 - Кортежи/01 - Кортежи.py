# Кортеж — это последовательность значений. Значения могут быть любого
# типа, а их индексы — целыми числами, и в этом отношении кортежи похожи на списки. Важное отличие заключается в том,
# что кортежи неизменяемы.

# region Создание Кортежа.
# nums = ()                # Создан пустой кортеж
# nums = (10,)              # Кортеж из одного элемента
# nums = (10, 20, 30)         # Кортеж из трех элементов
# nums = (10, "str", 30)     # Кортеж из трех элементов разного типа
# print(nums)

# Также можно использовать функцию tuple(), которая преобразует переданную ей последовательность в кортеж. Пример:
# nums = tuple()               # Пустой кортеж.
# nums = tuple('Hello')        # Преобразуем строку в кортеж.
# nums = tuple([10, 20, 30])      # Преобразуем список в кортеж.

# Вообще-то кортеж формируют запятые, а не круглые скобки. Скажем, вы можете создать кортеж так:
# nums = 10, 20, 30, 40, 50
# endregion Создание Кортежа.
# region Обращение к кортежу
# Позиция элемента в кортеже задается индексом. Нумерация элементов начинается с О (как и в случае со списком).
# Как и все последовательности, кортежи поддерживают обращение к элементу по индексу, получение среза,
# конкатенацию ( + ), проверку на вхождение (in) и повторение (*). Рассмотрим несколько примеров:

# print(nums[4], "<-- Доступ по индексу")
# print(nums[::-1], "<-- Показать кортеж в обратном порядке")
# print(nums[1:], "<-- Срез")
# print("Проверять наличии элемента : ", 5 in nums)
# print("Проверять на каком индексе стоит значение 30:", nums.index(30))
# print(nums * 2, "<-- Повтор")
# print("Конкатенация", nums + (1, 2, 3))
# endregion Обращение к кортежу
# ---------------------------------------------------------------------------------------------------------------------#
# Методы кортежей.
# Кортежи поддерживают всего два метода:
# indех(<Значение>[, <Начало>[, <Конец>]])
# соunt(<Значение>)

# Первый метод возвращает индекс элемента с указанным значением. Если
# такого элемента нет в кортеже, то генерируется исключение ValueError.
# Если не заданы второй и третий параметры, то поиск будет производиться
# с начала кортежа.

# tup = (1, 2, 3, 4, 5, 2, 7)
# tup.index(2)        # ответ 1
# tup.index(2, 2)     # ответ 5

# Второй метод подсчитывает количество элементов в кортеже с указанным значением:
# tup.count(2)        # ответ 2

# Чтобы не обрабатывать исключение ValueError, проверяйте сначала количество элементов методом count() -
# если оно отличное от О, тогда вычисляйте позиции элементов методом index().
# Других методов у кортежей нет, но вы можете использовать функции, предназначенные для работы с последовательностями.
# ---------------------------------------------------------------------------------------------------------------------#
# Перебор элементов кортежа
# Вывести содержимое кортежа можно функцией print():
# print(cars)
# Перебрать все элементы кортежа и что-то сделать с ними:
# for item in cars:
# ---------------------------------------------------------------------------------------------------------------------#
# Кортеж можно использовать как условие, например: 
# if not nums:
#   print ("В кортеже нет номеров!")
# Пустой кортеж интерпретируется как ложное условие (False), а кортеж, содержащий хотя бы один элемент - как истинное.
# Поскольку пустой кортеж интерпретируется как False, то условие not nums оказывается истинным, поэтому программа
# выведет строку "В кортеже нет номеров".
# ---------------------------------------------------------------------------------------------------------------------#
# Функция len() и оператор in
# К кортежам может применяться функция len(), возвращающая число элементов кортежа:
# print("Всего чисел: ", len(nums))
# Проверить существование элемента в кортеже можно так:
# if "10" in nums:
#   print("У вас есть число 10!")
# ---------------------------------------------------------------------------------------------------------------------#
# Так же в кортежах могут храниться списки и сами кортежи.
# some_list = [1, 2, 3]
# nums = (10, 20, 30, some_list)
# nums[3][0] = 100
# print(nums)
#
# # Что особенного можно делать с кортежем.
# user = "Вова", "Петров", 25     # создается кортеж.
# print(user)
# name, surename, age = user # значениям присваиваем переменные.
# print(age, name, surename)
#
# def get_user():
#     name = "Bob"
#     surname = "Ivanov"
#     age = 20
#     return name, surname, age
#
# user = get_user()
# print(name)

# ---------------------------------------------------------------------------------------------------------------------#
# Распаковка кортежа в отдельные переменные.
# Представим, что у нас есть кортеж из N элементов, который вы хотите "распаковать" в набор из N переменных. 
# Любая последовательность может быть распакована в переменные с использованием простой операции присваивания.
# Требование только одно:
# чтобы число переменных соответствовало числу элементов в структуре. 
# Например: 

# р = (4, 5)
# х, у = р
# print(х)    # 4
# print(у)    # 5

# data = ['Den', 50, 91.1, (2022, 12, 21)]
# name, shares, price, date = data
# print(name)     # 'Den'
# print(date)     # (2022, 12, 21)

# name, shares, price, (year, mon, day) = data
# print(name)     # 'Den'
# print(year)     # 2022
# print(mon)      # 12
# print(day)      # 21


# Если будет несоответствие в числе элементов, то вы получите ошибку. 
# Например: 
# р = ( 4, 5)
# х, у, z = р
# Traceback (most recent call last):
# File "<stdin>", line 1, in <module> 
# ValueError: need more than 2 values to unpack 

# Фактически, распаковка работает с любым объектом, который является итерируемым, а не только с кортежами или списками.
# К таким объектам относятся строки, файлы, итераторы и генераторы. Например:
# s = 'Hello'
# а, Ь, с, d, е = s
# print(b)  # 'e'

# ---------------------------------------------------------------------------------------------------------------------#
# При распаковке иногда бывает нужно отбросить определенные значения.
# У Python нет специального синтаксиса для этого, но вы можете просто указать имя переменной для значений, которые нужно
# отбросить. Например:

# data = ['Den', 50, 91.1, (2022, 12, 21)]
# _, shares, price, _ = data
# print(shares)
# print(price)

# Однако убедитесь, что имя переменной, которое вы выбираете, не используется для чего-то еще.
# Ситуация усложняется, когда вам нужно распаковать N элементов из итерируемого объекта, который может быть длиннее,
# чем N, что вызывает исключение "too тапу values to unpack".
# Для решения этой задачи может использоваться "звездочка". Например, 
# предположим, что в конце семестра вы решаете отбросить первые и последние классы домашней работы и выполнить только их
# среднюю часть. Если классов только четыре, то можно распаковать все четыре, но, что если 24?
# Тогда все упрощает "звездочка": 

# def drop_first_last (grades):
# first, *middle, last = grades 
# return avg(middle) 

# Рассмотрим и другой вариант использования. Предположим, что у вас есть записи, состоящие из 'имени пользователя и
# адреса электронной почты, cопровождаемые произвольным числом телефонных номеров. Вы можете распаковать эти записи так:

# record = ('Mark', 'mark@nit.center', '25-333-26', '888-12-11')
# name, email, *phone_numbers = user record
# print(name) # 'Mark'
# print(email)  # 'mark@nit.center'
# print(phone_numbers) # [ '25-333-26', 888-12-11']

# Стоит отметить, что переменная phone_numbers всегда будет списком, независимо от того, сколько телефонных номеров
# распаковано (даже если ни один). Таким образом, любой код, использующий phone_numbers, должен всегда считать ее
# списком или хотя бы производить дополнительную проверку типа. Переменная со звездочкой может также быть первой в
# списке. Например, скажем, что у вас есть последовательность значений, представляющая объемы продаж вашей компании за
# последние 8 кварталов. Если вы хотите видеть, как самый последний квартал складывается в средних по первым семи
# кварталам, вы можете выполнить подобный код:

# *trailing_qtrs, current_qtr = sales record
# trailing avg = sum(trailing qtrs) / len(trailing qtrs)
# return avg comparison(trailing_avg, current qtr)

# А вот как выглядит эта операция из интерпретатора Python:
# *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
# print(trailing) # [10, 8, 7, 1, 9, 5, 10]
# print(current) # 3

# Иногда нужно распаковать значения и отбросить их. Вы не можете указать
# пустое место с * при распаковке, но вы можете использовать звездочку 
# вместе с переменной _. Например: 
# record = ('Den', 50, 123.45, (17, 03, 2021))
# name, * (* , year) = record
# print(name) # 'Den'
# print(year) # 2021


# Есть определенная схожесть между звездообразными функциями распаковки и обработки списков различных функциональных
# ящиков. Например, если у вас есть список, вы можете легко разделить его на компоненты головы и хвоста. Например:
# iterns = (1, 10, 7, 4, 5, 9]
# head, *tail = iterns
# print(head)   # 1
# print(tail)   # [ 10, 7, 4, 5, 9]

# Можно было предположить написание функций, выполняющих такое разделение, в виде некоторого умного рекурсивного
# алгоритма. Например:

# def surn(iterns):
#   head, *tail iterns
#   return head + surn(tail) if tail else head
# print(surn(iterns)) # 36

# Однако знайте, что рекурсия действительно не сильная функция Python изза свойственного ей предела. Таким образом,
# этот последний пример приведен только из академического любопытства, на практике вы вряд ли будете
# использовать рекурсию в Python. 

# ---------------------------------------------------------------------------------------------------------------------#
#  01 - Списки vs кортежи
# Мы только что рассмотрели, как работать с кортежами в Python. Возникает закономерный вопрос - когда лучше
# использовать списки, а когда - кортежи? Понятно, что списки - лучше кортежей, поскольку можно изменять
# элементы списка. 
# Но не спешите отказываться от кортежей. У них есть следующие преимущества:

# • Кортежи работают быстрее. Система знает, что кортеж не изменится,поэтому его можно сохранит так, что операции с его
# элементами будут выполняться быстрее, чем с элементами списка. В небольших программа эта разница в скорости никак не
# проявит себя. Но при работе с большими последовательностями разница будет ощутимой.

# • Неизменяемость кортежей позволяет использовать их как константы.

# • Кортежи можно использовать в отдельных структурах данных, от которых Python требует неизмеримых значений.

# • Кортежи потребляют меньше памяти.

# • Кортежи можно использовать в качестве ключей словаря:

