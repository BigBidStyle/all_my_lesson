# region 7.2 - Кортежи.
# region Задача 1. Создание кортежей

# Заполните один кортеж десятью случайными целыми числами от 0 до 5 включительно.
# Также заполните второй кортеж числами от −5 до 0. Объедините два кортежа, создав тем самым третий кортеж.
# С помощью метода кортежа определите в нём количество нулей. Выведите на экран третий кортеж и количество нулей в нём.

# region Мое решение.
# import random
# tuple_1 = tuple(random.randint(0, 5) for num_1 in range(10))
# tuple_2 = tuple(random.randint(-5, 0) for num_2 in range(10))
# tuple_3 = tuple_1 + tuple_2
# print(f"Третий кортеж: {tuple_3}")
# if 0 in tuple_3:
#     print(f"Кол-во нулей: {tuple_3.count(0)}")
# else:
#     print(f"В кортеже нет нулей!")
# endregion Мое решение.
# region Решение SkillBox.
# import math
# import random
# def create_random_tuple(a, b, n):
#     return tuple([random.randint(a, b) for _ in range(n)])
#
# first = create_random_tuple(0, 5, 10)
# second = create_random_tuple(-5, 0, 10)
#
# third = first + second
# nulls_count = third.count(0)
# print(third, nulls_count)
# endregion Решение SkillBox.

# endregion Задача 1. Создание кортежей
# region Задача 2. Цилиндр

# Андрей однажды уже писал функции для расчёта площади сферы и объёма шара.
# И теперь для своей курсовой работы ему пришлось связаться с цилиндрами.

# Пользователь вводит два значения: радиус и высоту. Напишите функцию для расчёта площади боковой поверхности
# цилиндра и его полной площади.
# Функция должна возвращать два эти значения. После этого в основной программе выводятся оба ответа в две строки.

# Площадь боковой поверхности (r — радиус, h — высота): 2pi * r * h
# Полная площадь (S — площадь круга): side + 2 * s

# region Мое решение 2.
# import math
# def cylinder_math(r, h):
#     side = round(2 * math.pi * r * h, 2)
#     full = round(side + 2 * math.pi * r ** 2, 2)
#     return side, full
#
# bot_area, full_area = cylinder_math(int(input("Введите радиус: ")), int(input("Введите высоту: ")))
# print(f"Площадь боковой поверхности: {bot_area}")
# print(f"Полная площадь: {full_area}")
# endregion Мое решение 2.

# endregion Задача 2. Цилиндр
# region Задача 3. Неправильный код
# Дан код, в котором должно происходить следующее: изначально есть кортеж из пяти чисел. Затем вызывается функция,
# которая получает на вход кортеж чисел, генерирует случайный индекс и случайное значение,
# а затем по этим индексу и значению меняет сам кортеж. Функция должна возвращать кортеж и случайное значение.

# В основном коде функция используется два раза, и на экран два раза выводится новый кортеж и случайное значение.
# Причём второй раз выводится сумма первого случайного значения и второго.

# Однако код, который вам дали, оказался нерабочим. Исправьте его в соответствии с описанием.

# import random
#
#
# def change(nums):
#     index = random.randint(0, 5)
#     value = random.randint(100, 1000)
#     nums = list(nums)
#     nums[index] = value
#     return tuple(nums), value
#
#
# my_nums = 1, 2, 3, 4, 5
# new_nums, rand_val = change(my_nums)
# print(new_nums, rand_val)
#
# new_nums_2, rand_val_2 = change(new_nums)
# rand_val += rand_val_2
# print(new_nums_2, rand_val)

# endregion Задача 3. Неправильный код
# endregion 7.2 - Кортежи.
# region 7.3 - Функция enumerate. Перебор нескольких значений.
# region Задача 1. Саботаж!
# Какой-то нехороший человек решил подпортить жизнь frontend-разработчикам и добавил в код сайта символ ~ (тильда). Но
# программисты быстро решили эту проблему, пройдясь по всему коду маленькой программой.

# Пользователь вводит строку. Напишите программу, которая проходит по строке и выводит в консоль индексы символа ~. Для
# решения этой задачи (и остальных тоже) используйте функцию enumerate.

# Пример:
# Строка: so~mec~od~e
# Ответ: 2 6 9

# Мое решение
# text = tuple(input("Введите строку: "))
# numbering = tuple(str(index) for index, name in enumerate(text) if name == "~")
# numbering = " ".join(numbering)
# print(f"Ответ: {numbering}")


# Решение SkillBox.
# def get_indexes(where_to_search, what_to_search):
#     return [str(index) for index, letter in enumerate(where_to_search) if letter == what_to_search]
#
#
# text = input("Введите текст: ")
# print("Ответ:", " ".join(get_indexes(text, "~")))

# endregion Задача 1. Саботаж!
# region Задача 2. Словари из списков
# Создайте два списка, в каждом из которых лежит 10 случайных букв алфавита (могут повторяться). Затем для каждого
# списка создайте словарь из пар «индекс — значение» и выведите оба словаря на экран.

# Подсказка: random

# Пример:
# Первый список: ['й', 'р', 'с', 'г', 'а', 'а', 'т', 'ж', 'е', 'к']
# Второй список: ['д', 'а', 'а', 'в', 'т', 'ж', 'р', 'б', 'й', 'р']

# Первый словарь: {0: 'й', 1: 'р', 2: 'с', 3: 'г', 4: 'а', 5: 'а', 6: 'т', 7: 'ж', 8: 'е', 9: 'к'}
# Второй словарь: {0: 'д', 1: 'а', 2: 'а', 3: 'в', 4: 'т', 5: 'ж', 6: 'р', 7: 'б', 8: 'й', 9: 'р'}

# import random
# def get_random_letter(n):
#     return random.choices([chr(i) for i in range(ord("а"), ord("я"))], k=n)
#
# first_letters = get_random_letter(10)
# second_letters = get_random_letter(10)
# print(f"Первый список: {first_letters}")
# print(f"Второй список: {second_letters}\n")
#
# first_dictionary = dict(enumerate(first_letters))
# second_dictionary = dict(enumerate(second_letters))
# print(f"Первый словарь: {first_dictionary}")
# print(f"Первый словарь: {second_dictionary}")

# endregion Задача 2. Словари из списков
# endregion 7.3 - Функция enumerate. Перебор нескольких значений.
# region 7.4 - Перебор ключей и значений в словаре. Метод items
# region Задача 1. Кризис миновал
# Закупки грейпфрутов прекратились, и кризис в торговой компании закончился. И теперь можно вернуться к обыденным делам.
# Однако внезапно вы обнаружили, что старый скрипт, который выводит данные о фруктах, куда-то потерялся. Необходимо его
# восстановить.

# Дан словарь с парами «название фрукта — цена»:

# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }

# Вывести на экран словарь в следующем виде:

# apple -- 5600.2
# orange -- 3500.45
# banana -- 5000.0
# bergamot -- 3700.56
# durian -- 5987.23
# peach -- 10000.5
# pear -- 1020.0
# persimmon -- 310.0

# Мое решение
# incomes = {
#     'apple': 5600.20,
#     'orange': 3500.45,
#     'banana': 5000.00,
#     'bergamot': 3700.56,
#     'durian': 5987.23,
#     'peach': 10000.50,
#     'pear': 1020.00,
#     'persimmon': 310.00,
# }
# for fruites, price in incomes.items():
#     print(f"{fruites} -- {price}")
# Не используйте обращение по ключу словаря.

# endregion Задача 1. Кризис миновал
# region Задача 2. Сервер
# У вас есть данные о сервере, которые хранятся в виде вот такого словаря:

# server_data = {
#     "server": {
#         "host": "127.0.0.1",
#         "port": "10"
#     },
#     "configuration": {
#         "access": "true",
#         "login": "Ivan",
#         "password": "qwerty"
#     }
# }

# Напишите программу, которая выводит для пользователя эти данные так же красиво и понятно, как они представлены в
# словаре.

# Результат работы программы:
# server:
#     host: 127.0.0.1
#     port: 10
# configuration:
#     access: true
#     login: Ivan
#     password: qwerty

# Мое решение
# server_data = {
#     "server": {
#         "host": "127.0.0.1",
#         "port": "10"
#     },
#     "configuration": {
#         "access": "true",
#         "login": "Ivan",
#         "password": "qwerty"
#     }
# }
#
# for name, values in server_data.items():
#     print(f"{name}: ")
#     for name_1, values_1 in values.items():
#         print(f"\t{name_1}: {values_1}")
#
# Решение SkillBox
# server_data = {
#     "server": {
#         "host": "127.0.0.1",
#         "port": "10"
#     },
#     "configuration": {
#         "access": "true",
#         "login": "Ivan",
#         "password": "qwerty"
#     }
# }
#
# for tag, info in server_data.items():
#     print(tag + ":", "\n")
#     for key, value in info.items():
#         print("\t" + key + ": " + value, "\n")
# endregion Задача 2. Сервер
# region Задача 3. В одну строчку
# Нашему другу дали задачу: «Есть словарь, в котором ключи — это числа от 0 до 4, а значения ключей — числа 0, 100, 144,
# 20 и 19 соответственно. Нужно написать программу, которая выводит список тех значений, у которых ключ делится на 2.
# Причём программа должна быть в одну строчку.» Программа у друга работает, но её не приняли, так как в ней не
# используется правило «не повторяйся» — это когда части кода не повторяются. Помогите другу исправить решение задачи
# так, чтобы код в строчке не повторялся.

# # Решение друга:
# print([{0: 0, 1: 100, 2: 144, 3: 20, 4: 19}[i_key] for i_key in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19}
#        if i_key % 2 == 0])

# Мое решение
# print([meaning for i_key, meaning in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19}.items() if i_key % 2 == 0])

# Решение SkillBox
# print([i_value for i_key, i_value in {0: 0, 1: 100, 2: 144, 3: 20, 4: 19}.items() if i_key % 2 == 0])

# endregion Задача 3. В одну строчку
# endregion 7.4 - Перебор ключей и значений в словаре. Метод items
# region 7.5 - Составные ключи
# region Задача 1. Паспортные данные
# В базе данных поликлиники хранятся паспортные данные людей. Хранение реализовано с помощью словаря, состоящего из пар
# «Серия и номер паспорта — фамилия и имя». Серия и номер — составной ключ, а фамилия и имя — составное значение.

# data = {
#     (5000, 123456): ('Иванов', 'Василий'),
#     (6000, 111111): ('Иванов', 'Петр'),
#     (7000, 222222): ('Медведев', 'Алексей'),
#     (8000, 333333): ('Алексеев', 'Георгий'),
#     (9000, 444444): ('Георгиева', 'Мария')
# }

# Реализуйте функцию, которая по номеру и серии паспорта выдаёт имя и фамилию человека.
# Мое решение.
# data = {
#     (5000, 123456): ('Иванов', 'Василий'),
#     (6000, 111111): ('Иванов', 'Петр'),
#     (7000, 222222): ('Медведев', 'Алексей'),
#     (8000, 333333): ('Алексеев', 'Георгий'),
#     (9000, 444444): ('Георгиева', 'Мария')}
#
# def search_people(data, in_series, in_passport):
#     for number, people in data.items():
#         if in_series and in_passport in number:
#             print(people)
#         else:
#             print("Такого человека нет")
#
# input_number = int(input("Введите серию паспорта: "))
# input_series = int(input("Введите номер паспорта: "))
# search_people(data, input_series, input_number)

# Решенеи SkillBox
# data = {
#     (5000, 123456): ('Иванов', 'Василий'),
#     (6000, 111111): ('Иванов', 'Петр'),
#     (7000, 222222): ('Медведев', 'Алексей'),
#     (8000, 333333): ('Алексеев', 'Георгий'),
#     (9000, 444444): ('Георгиева', 'Мария')
# }
#
# number = int(input("Введите номер паспорта: "))
# series = int(input("Введите серию паспорта: "))
#
# number_and_series = (number, series)
#
# if number_and_series in data:
#     print(data[number_and_series])
# else:
#     print("Такого человека нет")
# endregion Задача 1. Паспортные данные
# region Задача 2. Контакты 2
# Мы уже реализовывали телефонную книгу для Степана, однако её проблема была в том, что туда нельзя было добавить людей
# с одинаковыми именами. Надо это исправить.
#
# Напишите программу, которая запрашивает у пользователя имя контакта, фамилию и номер телефона, добавляет их в словарь
# и выводит на экран текущий словарь контактов. Словарь состоит из пар «Ф. И. — телефон», где Ф. И. — это составной
# ключ. Запрос на добавление идёт бесконечно (но можно задать своё условие для завершения программы). Обеспечьте
# контроль ввода: если этот человек уже есть в словаре, то выведите соответствующее сообщение.

# Мое решение.
# contact = {}
# while True:
#     name = input("Введите имя: ")
#     surname = input("Введите фамилию: ")
#     name_surname = (name, surname)
#     if name_surname not in contact:
#         contact[name_surname] = int(input("Введите номер телефона: "))
#     else:
#         print("Такой контакт есть!")
#         break
#     print(contact)

# endregion Задача 2. Контакты 2
# endregion 7.5 - Составные ключи
